
eth_3.elf:     file format elf32-littlenios2
eth_3.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00002188

Program Header:
    LOAD off    0x00001000 vaddr 0x00002000 paddr 0x00002000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00002020 paddr 0x00002020 align 2**12
         filesz 0x000013bc memsz 0x000013bc flags r-x
    LOAD off    0x000023dc vaddr 0x000033dc paddr 0x0000346c align 2**12
         filesz 0x00000090 memsz 0x00000090 flags rw-
    LOAD off    0x000024fc vaddr 0x000034fc paddr 0x000034fc align 2**12
         filesz 0x00000000 memsz 0x000001c4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00002000  00002000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000168  00002020  00002020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001218  00002188  00002188  00001188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000003c  000033a0  000033a0  000023a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000090  000033dc  0000346c  000023dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000001c4  000034fc  000034fc  000024fc  2**2
                  ALLOC, SMALL_DATA
  6 .system_ram   00000000  000036c0  000036c0  0000246c  2**0
                  CONTENTS
  7 .rx_buf_ram   00000000  00005400  00005400  0000246c  2**0
                  CONTENTS
  8 .header_ram   00000000  00005600  00005600  0000246c  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  0000246c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000368  00000000  00000000  00002490  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00003ade  00000000  00000000  000027f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000157e  00000000  00000000  000062d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000016f0  00000000  00000000  00007854  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000064c  00000000  00000000  00008f44  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000015a8  00000000  00000000  00009590  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000175f  00000000  00000000  0000ab38  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000030  00000000  00000000  0000c298  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000170  00000000  00000000  0000c2c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0000dda2  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000c  00000000  00000000  0000dda5  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0000ddb1  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0000ddb2  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   0000000b  00000000  00000000  0000ddb3  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    0000000b  00000000  00000000  0000ddbe  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   0000000b  00000000  00000000  0000ddc9  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000b  00000000  00000000  0000ddd4  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000031  00000000  00000000  0000dddf  2**0
                  CONTENTS, READONLY
 28 .jdi          00005554  00000000  00000000  0000de10  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00084bcf  00000000  00000000  00013364  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 .entry
00002020 l    d  .exceptions	00000000 .exceptions
00002188 l    d  .text	00000000 .text
000033a0 l    d  .rodata	00000000 .rodata
000033dc l    d  .rwdata	00000000 .rwdata
000034fc l    d  .bss	00000000 .bss
000036c0 l    d  .system_ram	00000000 .system_ram
00005400 l    d  .rx_buf_ram	00000000 .rx_buf_ram
00005600 l    d  .header_ram	00000000 .header_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../eth_3_bsp//obj/HAL/src/crt0.o
000021d0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0000340c l     O .rwdata	00000030 rx_dma
000033dc l     O .rwdata	00000030 tx_dma
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
00002bf8 l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 strlen.c
00003518 g     O .bss	00000004 alt_instruction_exception_handler
00002b74 g     F .text	0000002c alt_main
000035c0 g     O .bss	00000100 alt_irq
0000346c g       *ABS*	00000000 __flash_rwdata_start
00002cd0 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
00005600 g       *ABS*	00000000 __alt_mem_header_ram
00003448 g     O .rwdata	00000004 ip
00002e5c g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
00003344 g     F .text	00000008 altera_nios2_gen2_irq_init
00002000 g     F .entry	0000001c __reset
00002ff0 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00002020 g       *ABS*	00000000 __flash_exceptions_start
0000351c g     O .bss	00000004 errno
00002878 g     F .text	00000044 pio_init
00002578 g     F .text	00000094 create_ip
00003510 g     O .bss	00000004 alt_argv
0000b43c g       *ABS*	00000000 _gp
000023e4 g     F .text	00000098 open_sgdma
000026f0 g     F .text	00000188 sgdma_rx_irq_handler
00003250 g     F .text	00000074 alt_find_dev
00002940 g     F .text	00000028 memcpy
000034fc g     O .bss	00000001 fl_proto
000032d0 g     F .text	00000074 alt_exception_cause_generated_bad_addr
00003060 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00003440 g     O .rwdata	00000004 udp
0000343c g     O .rwdata	00000004 tse
0000334c g     F .text	00000038 alt_icache_flush
00003450 g     O .rwdata	00000004 eth
00005400 g       *ABS*	00000000 __alt_mem_rx_buf_ram
00003520 g     O .bss	00000020 tx_descriptor_header
00002d78 g     F .text	0000001c alt_avalon_sgdma_stop
0000344c g     O .rwdata	00000004 arp
000031bc g     F .text	00000028 alt_dcache_flush
000036c0 g       *ABS*	00000000 __bss_end
00002a2c g     F .text	00000068 alt_iic_isr_register
00002c54 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
00003540 g     O .bss	00000020 rx_descriptor_end
00002a14 g     F .text	00000018 alt_ic_irq_enabled
00003508 g     O .bss	00000004 alt_irq_active
000020fc g     F .exceptions	00000060 alt_irq_handler
00002d94 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
00002000 g       *ABS*	00000000 __alt_mem_system_ram
00002988 g     F .text	00000018 alt_dcache_flush_all
00003560 g     O .bss	00000020 rx_descriptor
0000346c g       *ABS*	00000000 __ram_rwdata_end
00002e0c g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
000033dc g       *ABS*	00000000 __ram_rodata_end
0000345c g     O .rwdata	00000004 jtag_uart_0
000030b0 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
00002d50 g     F .text	00000010 alt_avalon_sgdma_register_callback
000036c0 g       *ABS*	00000000 end
0000215c g     F .exceptions	0000002c alt_instruction_exception_entry
00003ffc g       *ABS*	00000000 __alt_stack_pointer
00002e3c g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00002fb8 g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
00003038 g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
000022dc g     F .text	00000108 tse_init
00002188 g     F .text	0000004c _start
00003500 g     O .bss	00000004 sgdma_tx_dev
00002dc0 g     F .text	0000004c alt_avalon_sgdma_open
00002bc0 g     F .text	00000038 alt_sys_init
0000260c g     F .text	0000003c create_udp
000033dc g       *ABS*	00000000 __ram_rwdata_start
000033a0 g       *ABS*	00000000 __ram_rodata_start
00002910 g     F .text	00000030 memcmp
000036c0 g       *ABS*	00000000 __alt_stack_base
000031e4 g     F .text	0000006c alt_dev_llist_insert
00002d60 g     F .text	00000018 alt_avalon_sgdma_start
000034fc g       *ABS*	00000000 __bss_start
000026ac g     F .text	00000044 create_icmp
00002968 g     F .text	00000020 memset
000028bc g     F .text	00000054 main
0000350c g     O .bss	00000004 alt_envp
00003460 g     O .rwdata	00000008 alt_sgdma_list
00003468 g     O .rwdata	00000004 alt_errno
000033a0 g       *ABS*	00000000 __flash_rodata_start
00002ba0 g     F .text	00000020 alt_irq_init
00003514 g     O .bss	00000004 alt_argc
000024bc g     F .text	000000bc create_arp
00002648 g     F .text	00000064 calculate_checksum
00002020 g       .exceptions	00000000 alt_irq_entry
00002020 g       *ABS*	00000000 __ram_exceptions_start
000021d4 g     F .text	00000108 button_isr
000029a0 g     F .text	00000004 alt_ic_isr_register
0000346c g       *ABS*	00000000 _edata
000036c0 g       *ABS*	00000000 _end
00002188 g       *ABS*	00000000 __ram_exceptions_end
000029dc g     F .text	00000038 alt_ic_irq_disable
00003454 g     O .rwdata	00000001 RTP_PAYLOAD_TYPE
00003580 g     O .bss	00000020 tx_descriptor_end
000030f0 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
00003444 g     O .rwdata	00000004 icmp
0000247c g     F .text	00000040 create_eth
00003ffc g       *ABS*	00000000 __alt_data_end
00002020 g     F .exceptions	00000000 alt_exception
000035a0 g     O .bss	00000020 tx_descriptor_data
00003504 g     O .bss	00000004 sgdma_rx_dev
0000201c g       .entry	00000000 _exit
00003384 g     F .text	0000001c strlen
000032c4 g     F .text	0000000c alt_icache_flush_all
00003458 g     O .rwdata	00000004 alt_priority_mask
000029a4 g     F .text	00000038 alt_ic_irq_enable
00002f70 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
00002a94 g     F .text	000000e0 alt_load
00003138 g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00002000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
    2000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
    2004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
    2008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
    200c:	00bffd16 	blt	zero,r2,2004 <_gp+0xffff6bc8>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    2010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    2014:	08486214 	ori	at,at,8584
    jmp r1
    2018:	0800683a 	jmp	at

0000201c <_exit>:
    201c:	00000000 	call	0 <__alt_mem_system_ram-0x2000>

Disassembly of section .exceptions:

00002020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    2020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    2024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    2028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    202c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    2030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    2034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    2038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    203c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    2040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    2044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    2048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    204c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    2050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    2054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    2058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    205c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    2060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    2064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    2068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    206c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    2070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    2074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    2078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    207c:	10000326 	beq	r2,zero,208c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    2080:	20000226 	beq	r4,zero,208c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    2084:	00020fc0 	call	20fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    2088:	00000706 	br	20a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
    208c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
    2090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
    2094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
    2098:	000215c0 	call	215c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
    209c:	1000021e 	bne	r2,zero,20a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
    20a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    20a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    20a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    20ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    20b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    20b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    20b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    20bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    20c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    20c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    20c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    20cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    20d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    20d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    20d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    20dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    20e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    20e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    20e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    20ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    20f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    20f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    20f8:	ef80083a 	eret

000020fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    20fc:	defffe04 	addi	sp,sp,-8
    2100:	dfc00115 	stw	ra,4(sp)
    2104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    2108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    210c:	04000034 	movhi	r16,0
    2110:	840d7004 	addi	r16,r16,13760

  active = alt_irq_pending ();

  do
  {
    i = 0;
    2114:	0005883a 	mov	r2,zero
    mask = 1;
    2118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    211c:	20ca703a 	and	r5,r4,r3
    2120:	28000b26 	beq	r5,zero,2150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    2124:	100490fa 	slli	r2,r2,3
    2128:	8085883a 	add	r2,r16,r2
    212c:	10c00017 	ldw	r3,0(r2)
    2130:	11000117 	ldw	r4,4(r2)
    2134:	183ee83a 	callr	r3
    2138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    213c:	203ff51e 	bne	r4,zero,2114 <_gp+0xffff6cd8>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    2140:	dfc00117 	ldw	ra,4(sp)
    2144:	dc000017 	ldw	r16,0(sp)
    2148:	dec00204 	addi	sp,sp,8
    214c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    2150:	18c7883a 	add	r3,r3,r3
      i++;
    2154:	10800044 	addi	r2,r2,1

    } while (1);
    2158:	003ff006 	br	211c <_gp+0xffff6ce0>

0000215c <alt_instruction_exception_entry>:
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
    215c:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
    2160:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
    2164:	d0e03717 	ldw	r3,-32548(gp)
    2168:	18000426 	beq	r3,zero,217c <alt_instruction_exception_entry+0x20>
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
    216c:	10801f0c 	andi	r2,r2,124
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
    2170:	200b883a 	mov	r5,r4
    2174:	1008d0ba 	srli	r4,r2,2
    2178:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
    217c:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
    2180:	0005883a 	mov	r2,zero
    2184:	f800283a 	ret

Disassembly of section .text:

00002188 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
    2188:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
    218c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
    2190:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
    2194:	00bffd16 	blt	zero,r2,218c <_gp+0xffff6d50>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    2198:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    219c:	decfff14 	ori	sp,sp,16380
    movhi gp, %hi(_gp)
    21a0:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    21a4:	d6ad0f14 	ori	gp,gp,46140
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    21a8:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    21ac:	108d3f14 	ori	r2,r2,13564

    movhi r3, %hi(__bss_end)
    21b0:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    21b4:	18cdb014 	ori	r3,r3,14016

    beq r2, r3, 1f
    21b8:	10c00326 	beq	r2,r3,21c8 <_start+0x40>

0:
    stw zero, (r2)
    21bc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    21c0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    21c4:	10fffd36 	bltu	r2,r3,21bc <_gp+0xffff6d80>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    21c8:	0002a940 	call	2a94 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    21cc:	0002b740 	call	2b74 <alt_main>

000021d0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    21d0:	003fff06 	br	21d0 <_gp+0xffff6d94>

000021d4 <button_isr>:



// Handler of timer interrupt
void button_isr(void* context)
{
    21d4:	defff904 	addi	sp,sp,-28
    21d8:	dc000415 	stw	r16,16(sp)
    21dc:	dfc00615 	stw	ra,24(sp)
    21e0:	dc400515 	stw	r17,20(sp)
    // Clear flag of interrupt

	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ETH_IRQ_PIO_BASE, 0x1);
    21e4:	04000044 	movi	r16,1
    21e8:	00800304 	movi	r2,12
    21ec:	14000035 	stwio	r16,0(r2)

    if (fl_proto == 1)
    21f0:	d4603003 	ldbu	r17,-32576(gp)
    21f4:	8c00201e 	bne	r17,r16,2278 <button_isr+0xa4>
    {
    	alt_dcache_flush_all();
    21f8:	00029880 	call	2988 <alt_dcache_flush_all>
		alt_avalon_sgdma_construct_mem_to_stream_desc(&tx_descriptor_header, &tx_descriptor_data, (alt_u32 *)HEADER_RAM_BASE, 54, 0, 1, 0, 0);
    21fc:	01400034 	movhi	r5,0
    2200:	01000034 	movhi	r4,0
    2204:	01c00d84 	movi	r7,54
    2208:	01958004 	movi	r6,22016
    220c:	294d6804 	addi	r5,r5,13728
    2210:	210d4804 	addi	r4,r4,13600
    2214:	d8000315 	stw	zero,12(sp)
    2218:	d8000215 	stw	zero,8(sp)
    221c:	dc400115 	stw	r17,4(sp)
    2220:	d8000015 	stw	zero,0(sp)
    2224:	00030b00 	call	30b0 <alt_avalon_sgdma_construct_mem_to_stream_desc>
		alt_avalon_sgdma_construct_mem_to_stream_desc(&tx_descriptor_data, &tx_descriptor_end, TX_DMA_M_READ_TX_BUFF_RAM_BASE, 1280, 0, 0, 1, 0);
    2228:	01400034 	movhi	r5,0
    222c:	01000034 	movhi	r4,0
    2230:	294d6004 	addi	r5,r5,13696
    2234:	210d6804 	addi	r4,r4,13728
    2238:	d8000315 	stw	zero,12(sp)
    223c:	dc400215 	stw	r17,8(sp)
    2240:	d8000115 	stw	zero,4(sp)
    2244:	d8000015 	stw	zero,0(sp)
    2248:	01c14004 	movi	r7,1280
    224c:	000d883a 	mov	r6,zero
    2250:	00030b00 	call	30b0 <alt_avalon_sgdma_construct_mem_to_stream_desc>

		alt_avalon_sgdma_do_async_transfer(sgdma_tx_dev, &tx_descriptor_header);
    2254:	d1203117 	ldw	r4,-32572(gp)
    2258:	01400034 	movhi	r5,0
    225c:	294d4804 	addi	r5,r5,13600
    2260:	0002c540 	call	2c54 <alt_avalon_sgdma_do_async_transfer>
		while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor_data) != 0);
    2264:	01000034 	movhi	r4,0
    2268:	210d6804 	addi	r4,r4,13728
    226c:	0002d940 	call	2d94 <alt_avalon_sgdma_check_descriptor_status>
    2270:	103ffc1e 	bne	r2,zero,2264 <_gp+0xffff6e28>
    2274:	00001406 	br	22c8 <button_isr+0xf4>
    }
    else
    {
    	alt_dcache_flush_all();
    2278:	00029880 	call	2988 <alt_dcache_flush_all>
		alt_avalon_sgdma_construct_mem_to_stream_desc(&tx_descriptor_header, &tx_descriptor_data, (alt_u32 *)HEADER_RAM_BASE, 42, 0, 1, 1, 0);
    227c:	01400034 	movhi	r5,0
    2280:	01000034 	movhi	r4,0
    2284:	294d6804 	addi	r5,r5,13728
    2288:	210d4804 	addi	r4,r4,13600
    228c:	d8000315 	stw	zero,12(sp)
    2290:	dc000215 	stw	r16,8(sp)
    2294:	dc000115 	stw	r16,4(sp)
    2298:	d8000015 	stw	zero,0(sp)
    229c:	01c00a84 	movi	r7,42
    22a0:	01958004 	movi	r6,22016
    22a4:	00030b00 	call	30b0 <alt_avalon_sgdma_construct_mem_to_stream_desc>
		alt_avalon_sgdma_do_async_transfer(sgdma_tx_dev, &tx_descriptor_header);
    22a8:	d1203117 	ldw	r4,-32572(gp)
    22ac:	01400034 	movhi	r5,0
    22b0:	294d4804 	addi	r5,r5,13600
    22b4:	0002c540 	call	2c54 <alt_avalon_sgdma_do_async_transfer>
		while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor_header) != 0);
    22b8:	01000034 	movhi	r4,0
    22bc:	210d4804 	addi	r4,r4,13600
    22c0:	0002d940 	call	2d94 <alt_avalon_sgdma_check_descriptor_status>
    22c4:	103ffc1e 	bne	r2,zero,22b8 <_gp+0xffff6e7c>
    }


}
    22c8:	dfc00617 	ldw	ra,24(sp)
    22cc:	dc400517 	ldw	r17,20(sp)
    22d0:	dc000417 	ldw	r16,16(sp)
    22d4:	dec00704 	addi	sp,sp,28
    22d8:	f800283a 	ret

000022dc <tse_init>:

// Initialization of Triple-Speed Ethernet
void tse_init(void)
{
	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x00;
    22dc:	d0e00017 	ldw	r3,-32768(gp)

	// Disable read and write transfers and wait
	IOWR(tse, 0x02, 0x00800220);
    22e0:	00802034 	movhi	r2,128
    22e4:	10808804 	addi	r2,r2,544

// Initialization of Triple-Speed Ethernet
void tse_init(void)
{
	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x00;
    22e8:	18000f15 	stw	zero,60(r3)

	// Disable read and write transfers and wait
	IOWR(tse, 0x02, 0x00800220);
    22ec:	18800235 	stwio	r2,8(r3)
	while ( IORD(tse, 0x02) !=  0x00800220 );
    22f0:	d0e00017 	ldw	r3,-32768(gp)
    22f4:	19000237 	ldwio	r4,8(r3)
    22f8:	20bffd1e 	bne	r4,r2,22f0 <_gp+0xffff6eb4>

	// MAC FIFO Configuration
	IOWR(tse, 0x09, TSE_RECEIVE_FIFO_DEPTH-16);
    22fc:	01001c04 	movi	r4,112
    2300:	19000935 	stwio	r4,36(r3)
	IOWR(tse, 0x0E, 3);
    2304:	d0e00017 	ldw	r3,-32768(gp)
    2308:	014000c4 	movi	r5,3
    230c:	19400e35 	stwio	r5,56(r3)
	IOWR(tse, 0x0D, 8);
    2310:	d1600017 	ldw	r5,-32768(gp)
    2314:	00c00204 	movi	r3,8
    2318:	28c00d35 	stwio	r3,52(r5)
	IOWR(tse, 0x07, TSE_RECEIVE_FIFO_DEPTH-16);
    231c:	d1600017 	ldw	r5,-32768(gp)
    2320:	29000735 	stwio	r4,28(r5)
	IOWR(tse, 0x0C, 8);
    2324:	d1200017 	ldw	r4,-32768(gp)
    2328:	20c00c35 	stwio	r3,48(r4)
	IOWR(tse, 0x0B, 8);
    232c:	d1200017 	ldw	r4,-32768(gp)
    2330:	20c00b35 	stwio	r3,44(r4)
	IOWR(tse, 0x0A, 0);
    2334:	d0e00017 	ldw	r3,-32768(gp)
    2338:	18000a35 	stwio	zero,40(r3)
	IOWR(tse, 0x08, 0);
    233c:	d0e00017 	ldw	r3,-32768(gp)
    2340:	18000835 	stwio	zero,32(r3)

	// Initialize the MAC address
	IOWR(tse, 0x03, 0xEFBEADDE);
    2344:	d0e00017 	ldw	r3,-32768(gp)
    2348:	013beff4 	movhi	r4,61375
    234c:	212b7784 	addi	r4,r4,-21026
    2350:	19000335 	stwio	r4,12(r3)
	IOWR(tse, 0x04, 0x0000FECA);
    2354:	d0e00017 	ldw	r3,-32768(gp)
    2358:	013fb294 	movui	r4,65226
    235c:	19000435 	stwio	r4,16(r3)

	// MAC function configuration
	IOWR(tse, 0x05, 1280 + 54);
    2360:	d0e00017 	ldw	r3,-32768(gp)
    2364:	01014d84 	movi	r4,1334
    2368:	19000535 	stwio	r4,20(r3)
	IOWR(tse, 0x17, 12);
    236c:	d0e00017 	ldw	r3,-32768(gp)
    2370:	01000304 	movi	r4,12
    2374:	19001735 	stwio	r4,92(r3)
	IOWR(tse, 0x06, 0xFFFF);
    2378:	d0e00017 	ldw	r3,-32768(gp)
    237c:	013fffd4 	movui	r4,65535
    2380:	19000635 	stwio	r4,24(r3)
	IOWR(tse, 0x02, 0x00800220);
    2384:	d0e00017 	ldw	r3,-32768(gp)
    2388:	18800235 	stwio	r2,8(r3)
	while (IORD(tse, 0x02 ) != 0x00800220);
    238c:	d0e00017 	ldw	r3,-32768(gp)
    2390:	18c00204 	addi	r3,r3,8
    2394:	19000037 	ldwio	r4,0(r3)
    2398:	20bffc1e 	bne	r4,r2,238c <_gp+0xffff6f50>

	// Software reset the PHY chip and wait
	IOWR(tse, 0x02, (IORD(tse, 0x02) | 0x2000));
    239c:	18800037 	ldwio	r2,0(r3)
    23a0:	10880014 	ori	r2,r2,8192
    23a4:	18800035 	stwio	r2,0(r3)
	while ((IORD(tse, 0x02) & 0x2000) != 0);
    23a8:	d0a00017 	ldw	r2,-32768(gp)
    23ac:	10c00237 	ldwio	r3,8(r2)
    23b0:	18c8000c 	andi	r3,r3,8192
    23b4:	183ffc1e 	bne	r3,zero,23a8 <_gp+0xffff6f6c>
	*(tse + 0x02 ) = *(tse + 0x02 ) | 0x0080023B;
    23b8:	11000217 	ldw	r4,8(r2)
    23bc:	00c02034 	movhi	r3,128
    23c0:	18c08ec4 	addi	r3,r3,571
    23c4:	20c8b03a 	or	r4,r4,r3
    23c8:	11000215 	stw	r4,8(r2)
	while ( *(tse + 0x02 ) != ( *(tse + 0x02) | 0x0080023B ) );
    23cc:	11400217 	ldw	r5,8(r2)
    23d0:	11000217 	ldw	r4,8(r2)
    23d4:	20c8b03a 	or	r4,r4,r3
    23d8:	293ffc1e 	bne	r5,r4,23cc <_gp+0xffff6f90>

	IOWR(tse, 0x3a, 0x0000);
    23dc:	10003a35 	stwio	zero,232(r2)
    23e0:	f800283a 	ret

000023e4 <open_sgdma>:

// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
    23e4:	01000034 	movhi	r4,0

}

// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
    23e8:	defffe04 	addi	sp,sp,-8
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
    23ec:	210ce804 	addi	r4,r4,13216

}

// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
    23f0:	dfc00115 	stw	ra,4(sp)
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
    23f4:	0002dc00 	call	2dc0 <alt_avalon_sgdma_open>
    23f8:	d0a03115 	stw	r2,-32572(gp)
	if (sgdma_tx_dev == NULL) return(1);
    23fc:	10001926 	beq	r2,zero,2464 <open_sgdma+0x80>

	// Transmit device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/rx_dma");
    2400:	01000034 	movhi	r4,0
    2404:	210ceb04 	addi	r4,r4,13228
    2408:	0002dc00 	call	2dc0 <alt_avalon_sgdma_open>
    240c:	d0a03215 	stw	r2,-32568(gp)
	if (sgdma_rx_dev == NULL) return(2);
    2410:	10001626 	beq	r2,zero,246c <open_sgdma+0x88>

	// Register receive interrupt handler and allocate memory area
	alt_avalon_sgdma_register_callback(sgdma_rx_dev, (alt_avalon_sgdma_callback)sgdma_rx_irq_handler, 0x00000014, NULL);
    2414:	01400034 	movhi	r5,0
    2418:	1009883a 	mov	r4,r2
    241c:	000f883a 	mov	r7,zero
    2420:	01800504 	movi	r6,20
    2424:	2949bc04 	addi	r5,r5,9968
    2428:	0002d500 	call	2d50 <alt_avalon_sgdma_register_callback>
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
    242c:	01400034 	movhi	r5,0
    2430:	01000034 	movhi	r4,0
    2434:	000f883a 	mov	r7,zero
    2438:	01959904 	movi	r6,22116
    243c:	294d5004 	addi	r5,r5,13632
    2440:	210d5804 	addi	r4,r4,13664
    2444:	d8000015 	stw	zero,0(sp)
    2448:	00030380 	call	3038 <alt_avalon_sgdma_construct_stream_to_mem_desc>
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);
    244c:	d1203217 	ldw	r4,-32568(gp)
    2450:	01400034 	movhi	r5,0
    2454:	294d5804 	addi	r5,r5,13664
    2458:	0002c540 	call	2c54 <alt_avalon_sgdma_do_async_transfer>

	return(0);
    245c:	0005883a 	mov	r2,zero
    2460:	00000306 	br	2470 <open_sgdma+0x8c>
// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
	if (sgdma_tx_dev == NULL) return(1);
    2464:	00800044 	movi	r2,1
    2468:	00000106 	br	2470 <open_sgdma+0x8c>

	// Transmit device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/rx_dma");
	if (sgdma_rx_dev == NULL) return(2);
    246c:	00800084 	movi	r2,2
	alt_avalon_sgdma_register_callback(sgdma_rx_dev, (alt_avalon_sgdma_callback)sgdma_rx_irq_handler, 0x00000014, NULL);
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);

	return(0);
}
    2470:	dfc00117 	ldw	ra,4(sp)
    2474:	dec00204 	addi	sp,sp,8
    2478:	f800283a 	ret

0000247c <create_eth>:
	memset(frame_pc, 0, 100);
}

// Create ETH header (struct eth, type - encapsulation protocol)
void create_eth(struct eth_hdr *eth)
{
    247c:	defffe04 	addi	sp,sp,-8
    2480:	dc000015 	stw	r16,0(sp)
	memcpy(eth->mac_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", 6);
    2484:	01400034 	movhi	r5,0
    2488:	04000184 	movi	r16,6
    248c:	800d883a 	mov	r6,r16
    2490:	294cee04 	addi	r5,r5,13240
	memset(frame_pc, 0, 100);
}

// Create ETH header (struct eth, type - encapsulation protocol)
void create_eth(struct eth_hdr *eth)
{
    2494:	dfc00115 	stw	ra,4(sp)
	memcpy(eth->mac_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", 6);
    2498:	00029400 	call	2940 <memcpy>
	memcpy(eth->mac_src, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    249c:	01400034 	movhi	r5,0
    24a0:	800d883a 	mov	r6,r16
    24a4:	294cf004 	addi	r5,r5,13248
    24a8:	1409883a 	add	r4,r2,r16
}
    24ac:	dfc00117 	ldw	ra,4(sp)
    24b0:	dc000017 	ldw	r16,0(sp)
    24b4:	dec00204 	addi	sp,sp,8

// Create ETH header (struct eth, type - encapsulation protocol)
void create_eth(struct eth_hdr *eth)
{
	memcpy(eth->mac_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", 6);
	memcpy(eth->mac_src, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    24b8:	00029401 	jmpi	2940 <memcpy>

000024bc <create_arp>:
}

// Create ARP packet (struct arp, operation - request/reply)
void create_arp(struct arp_packet *arp, alt_u16 operation)
{
    24bc:	defffc04 	addi	sp,sp,-16
    24c0:	dfc00315 	stw	ra,12(sp)
    24c4:	dc800215 	stw	r18,8(sp)
    24c8:	dc400115 	stw	r17,4(sp)
    24cc:	dc000015 	stw	r16,0(sp)
	arp->eth_type = __builtin_bswap16(0x0806);
    24d0:	00818204 	movi	r2,1544
    24d4:	2080000d 	sth	r2,0(r4)
	arp->hw_type = __builtin_bswap16(0x0001);
    24d8:	00804004 	movi	r2,256
    24dc:	2080008d 	sth	r2,2(r4)
	arp->proto_type = __builtin_bswap16(0x0800);
    24e0:	00800204 	movi	r2,8
    24e4:	2080010d 	sth	r2,4(r4)
	arp->hw_len = 6;
    24e8:	00800184 	movi	r2,6
    24ec:	20800185 	stb	r2,6(r4)
	arp->proto_len = 4;

	// Operation (ARP-request = 1, ARP-reply = 2)
	arp->operation = __builtin_bswap16(operation);
    24f0:	297fffcc 	andi	r5,r5,65535
{
	arp->eth_type = __builtin_bswap16(0x0806);
	arp->hw_type = __builtin_bswap16(0x0001);
	arp->proto_type = __builtin_bswap16(0x0800);
	arp->hw_len = 6;
	arp->proto_len = 4;
    24f4:	00800104 	movi	r2,4
    24f8:	208001c5 	stb	r2,7(r4)

	// Operation (ARP-request = 1, ARP-reply = 2)
	arp->operation = __builtin_bswap16(operation);
    24fc:	2804923a 	slli	r2,r5,8
    2500:	280ad23a 	srli	r5,r5,8

	memcpy(arp->sender_mac, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    2504:	04800184 	movi	r18,6
	memcpy(eth->mac_src, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
}

// Create ARP packet (struct arp, operation - request/reply)
void create_arp(struct arp_packet *arp, alt_u16 operation)
{
    2508:	2021883a 	mov	r16,r4
	arp->proto_type = __builtin_bswap16(0x0800);
	arp->hw_len = 6;
	arp->proto_len = 4;

	// Operation (ARP-request = 1, ARP-reply = 2)
	arp->operation = __builtin_bswap16(operation);
    250c:	114ab03a 	or	r5,r2,r5
    2510:	2140020d 	sth	r5,8(r4)

	memcpy(arp->sender_mac, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    2514:	01400034 	movhi	r5,0
    2518:	900d883a 	mov	r6,r18
    251c:	294cf004 	addi	r5,r5,13248
    2520:	21000284 	addi	r4,r4,10
    2524:	00029400 	call	2940 <memcpy>
	memcpy(arp->sender_ip, "\xC0\xA8\x01\x02", 4);
    2528:	04400104 	movi	r17,4
    252c:	01400034 	movhi	r5,0
    2530:	880d883a 	mov	r6,r17
    2534:	81000404 	addi	r4,r16,16
    2538:	294cf204 	addi	r5,r5,13256
    253c:	00029400 	call	2940 <memcpy>
	memset(arp->target_mac, 0, 6);
    2540:	900d883a 	mov	r6,r18
    2544:	81000504 	addi	r4,r16,20
    2548:	000b883a 	mov	r5,zero
    254c:	00029680 	call	2968 <memset>
	memcpy(arp->target_ip, "\xC0\xA8\x01\x05", 4);
    2550:	01400034 	movhi	r5,0
    2554:	880d883a 	mov	r6,r17
    2558:	294cf404 	addi	r5,r5,13264
    255c:	81000684 	addi	r4,r16,26
}
    2560:	dfc00317 	ldw	ra,12(sp)
    2564:	dc800217 	ldw	r18,8(sp)
    2568:	dc400117 	ldw	r17,4(sp)
    256c:	dc000017 	ldw	r16,0(sp)
    2570:	dec00404 	addi	sp,sp,16
	arp->operation = __builtin_bswap16(operation);

	memcpy(arp->sender_mac, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
	memcpy(arp->sender_ip, "\xC0\xA8\x01\x02", 4);
	memset(arp->target_mac, 0, 6);
	memcpy(arp->target_ip, "\xC0\xA8\x01\x05", 4);
    2574:	00029401 	jmpi	2940 <memcpy>

00002578 <create_ip>:
}

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
    2578:	defffd04 	addi	sp,sp,-12
    257c:	dc400115 	stw	r17,4(sp)
    2580:	dc000015 	stw	r16,0(sp)
    2584:	dfc00215 	stw	ra,8(sp)
	ip->eth_type = __builtin_bswap16(0x0800);
    2588:	00800204 	movi	r2,8
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
    258c:	31800584 	addi	r6,r6,22
}

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
    2590:	2080000d 	sth	r2,0(r4)
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
    2594:	31bfffcc 	andi	r6,r6,65535

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
    2598:	00801144 	movi	r2,69
    259c:	20800085 	stb	r2,2(r4)
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
    25a0:	3004923a 	slli	r2,r6,8
    25a4:	300cd23a 	srli	r6,r6,8
	ip->id = 0;
	ip->flags_offset = 0;
	ip->ttl = 0x40;
	ip->protocol = protocol;
    25a8:	214002c5 	stb	r5,11(r4)
	ip->checksum = 0;
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
    25ac:	04400104 	movi	r17,4
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
    25b0:	118cb03a 	or	r6,r2,r6
	ip->id = 0;
	ip->flags_offset = 0;
	ip->ttl = 0x40;
	ip->protocol = protocol;
	ip->checksum = 0;
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
    25b4:	01400034 	movhi	r5,0
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
	ip->id = 0;
	ip->flags_offset = 0;
	ip->ttl = 0x40;
    25b8:	00801004 	movi	r2,64
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
    25bc:	2180010d 	sth	r6,4(r4)
	memcpy(arp->target_ip, "\xC0\xA8\x01\x05", 4);
}

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
    25c0:	2021883a 	mov	r16,r4
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
    25c4:	200000c5 	stb	zero,3(r4)
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + data_len);
	ip->id = 0;
    25c8:	2000018d 	sth	zero,6(r4)
	ip->flags_offset = 0;
    25cc:	2000020d 	sth	zero,8(r4)
	ip->ttl = 0x40;
    25d0:	20800285 	stb	r2,10(r4)
	ip->protocol = protocol;
	ip->checksum = 0;
    25d4:	2000030d 	sth	zero,12(r4)
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
    25d8:	880d883a 	mov	r6,r17
    25dc:	294cf204 	addi	r5,r5,13256
    25e0:	21000384 	addi	r4,r4,14
    25e4:	00029400 	call	2940 <memcpy>
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
    25e8:	01400034 	movhi	r5,0
    25ec:	880d883a 	mov	r6,r17
    25f0:	294cf404 	addi	r5,r5,13264
    25f4:	81000484 	addi	r4,r16,18
}
    25f8:	dfc00217 	ldw	ra,8(sp)
    25fc:	dc400117 	ldw	r17,4(sp)
    2600:	dc000017 	ldw	r16,0(sp)
    2604:	dec00304 	addi	sp,sp,12
	ip->flags_offset = 0;
	ip->ttl = 0x40;
	ip->protocol = protocol;
	ip->checksum = 0;
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
    2608:	00029401 	jmpi	2940 <memcpy>

0000260c <create_udp>:
}

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
    260c:	00a304c4 	movi	r2,-29677
	udp->port_dest = __builtin_bswap16(dest_port);
    2610:	297fffcc 	andi	r5,r5,65535
}

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
    2614:	2080000d 	sth	r2,0(r4)
	udp->port_dest = __builtin_bswap16(dest_port);
    2618:	2804923a 	slli	r2,r5,8
    261c:	280ad23a 	srli	r5,r5,8
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    2620:	31800204 	addi	r6,r6,8
    2624:	31bfffcc 	andi	r6,r6,65535

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
	udp->port_dest = __builtin_bswap16(dest_port);
    2628:	114ab03a 	or	r5,r2,r5
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    262c:	3004923a 	slli	r2,r6,8
    2630:	300cd23a 	srli	r6,r6,8

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
	udp->port_dest = __builtin_bswap16(dest_port);
    2634:	2140008d 	sth	r5,2(r4)
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
	udp->checksum = 0;
    2638:	2000018d 	sth	zero,6(r4)
// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
	udp->port_dest = __builtin_bswap16(dest_port);
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    263c:	118cb03a 	or	r6,r2,r6
    2640:	2180010d 	sth	r6,4(r4)
	udp->checksum = 0;
    2644:	f800283a 	ret

00002648 <calculate_checksum>:
}

// Calculate checksum for IP/ICMP/UDP/TCP
alt_u16 calculate_checksum(alt_u8* data, alt_u32 length)
{
    2648:	200d883a 	mov	r6,r4
    alt_u16* buffer = (alt_u16 *)data;
    alt_u16 temp = 0;

    while (length > 1)
    264c:	2805883a 	mov	r2,r5

// Calculate checksum for IP/ICMP/UDP/TCP
alt_u16 calculate_checksum(alt_u8* data, alt_u32 length)
{
    alt_u16* buffer = (alt_u16 *)data;
    alt_u16 temp = 0;
    2650:	0007883a 	mov	r3,zero

    while (length > 1)
    2654:	01c00044 	movi	r7,1
    2658:	3880052e 	bgeu	r7,r2,2670 <calculate_checksum+0x28>
    {
        temp += *buffer++;
    265c:	3200000b 	ldhu	r8,0(r6)
        length -= 2;
    2660:	10bfff84 	addi	r2,r2,-2
    2664:	31800084 	addi	r6,r6,2
    alt_u16* buffer = (alt_u16 *)data;
    alt_u16 temp = 0;

    while (length > 1)
    {
        temp += *buffer++;
    2668:	40c7883a 	add	r3,r8,r3
    266c:	003ffa06 	br	2658 <_gp+0xffff721c>
    2670:	2804d07a 	srli	r2,r5,1
        length -= 2;
    }

    if (length == 1) temp += *(alt_u8 *)buffer << 8;
    2674:	288bc83a 	sub	r5,r5,r2
    2678:	108d883a 	add	r6,r2,r2
    267c:	288bc83a 	sub	r5,r5,r2
    2680:	00800044 	movi	r2,1
    2684:	2189883a 	add	r4,r4,r6
    2688:	2880031e 	bne	r5,r2,2698 <calculate_checksum+0x50>
    268c:	20800003 	ldbu	r2,0(r4)
    2690:	1004923a 	slli	r2,r2,8
    2694:	10c7883a 	add	r3,r2,r3
    while (temp >> 16) temp = (temp & 0xFFFF) + (temp >> 16);
    return ~((temp >> 8) | (temp << 8));
    2698:	1804923a 	slli	r2,r3,8
    269c:	18ffffcc 	andi	r3,r3,65535
    26a0:	1806d23a 	srli	r3,r3,8
}
    26a4:	10c4303a 	nor	r2,r2,r3
    26a8:	f800283a 	ret

000026ac <create_icmp>:
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
}

// Create ICMP packet
void create_icmp(struct icmp_packet *icmp, alt_u16 id, alt_u16 seq, alt_u8 *data)
{
    26ac:	defffe04 	addi	sp,sp,-8
	icmp->type = 0;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->id = id;
    26b0:	2140010d 	sth	r5,4(r4)
}

// Create ICMP packet
void create_icmp(struct icmp_packet *icmp, alt_u16 id, alt_u16 seq, alt_u8 *data)
{
	icmp->type = 0;
    26b4:	20000005 	stb	zero,0(r4)
	icmp->code = 0;
    26b8:	20000045 	stb	zero,1(r4)
	icmp->checksum = 0;
    26bc:	2000008d 	sth	zero,2(r4)
	icmp->id = id;
	icmp->sequence = seq;
    26c0:	2180018d 	sth	r6,6(r4)
	icmp->data = data;
    26c4:	21c00215 	stw	r7,8(r4)
	icmp->checksum = calculate_checksum((alt_u8 *)icmp, sizeof(icmp));
    26c8:	01400104 	movi	r5,4
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
}

// Create ICMP packet
void create_icmp(struct icmp_packet *icmp, alt_u16 id, alt_u16 seq, alt_u8 *data)
{
    26cc:	dc000015 	stw	r16,0(sp)
    26d0:	dfc00115 	stw	ra,4(sp)
    26d4:	2021883a 	mov	r16,r4
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->id = id;
	icmp->sequence = seq;
	icmp->data = data;
	icmp->checksum = calculate_checksum((alt_u8 *)icmp, sizeof(icmp));
    26d8:	00026480 	call	2648 <calculate_checksum>
    26dc:	8080008d 	sth	r2,2(r16)
}
    26e0:	dfc00117 	ldw	ra,4(sp)
    26e4:	dc000017 	ldw	r16,0(sp)
    26e8:	dec00204 	addi	sp,sp,8
    26ec:	f800283a 	ret

000026f0 <sgdma_rx_irq_handler>:
	return(0);
}

// Handler of SGDMA Receive interrupt
void sgdma_rx_irq_handler(void *context)
{
    26f0:	defff904 	addi	sp,sp,-28
    26f4:	dfc00615 	stw	ra,24(sp)
    26f8:	dc400515 	stw	r17,20(sp)
    26fc:	dc000415 	stw	r16,16(sp)
	while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0);
    2700:	01000034 	movhi	r4,0
    2704:	210d5804 	addi	r4,r4,13664
    2708:	0002d940 	call	2d94 <alt_avalon_sgdma_check_descriptor_status>
    270c:	103ffc1e 	bne	r2,zero,2700 <_gp+0xffff72c4>

	alt_u8 *frame_pc = (alt_u8 *)(HEADER_RAM_BASE + 100);
	if ((memcmp(frame_pc + 12, "\x08\x06", 2) == 0) && frame_pc[21] == 0x02)
    2710:	04000084 	movi	r16,2
    2714:	01400034 	movhi	r5,0
    2718:	800d883a 	mov	r6,r16
    271c:	294cf604 	addi	r5,r5,13272
    2720:	01159c04 	movi	r4,22128
    2724:	00029100 	call	2910 <memcmp>
    2728:	1000081e 	bne	r2,zero,274c <sgdma_rx_irq_handler+0x5c>
    272c:	00959e44 	movi	r2,22137
    2730:	10800003 	ldbu	r2,0(r2)
    2734:	1400051e 	bne	r2,r16,274c <sgdma_rx_irq_handler+0x5c>
	{
		fl_proto = 0;  // Заглушка

		memcpy(eth->mac_dest, (frame_pc + 22), 6);
    2738:	d1200517 	ldw	r4,-32748(gp)
    273c:	01800184 	movi	r6,6
    2740:	01559e84 	movi	r5,22138
	while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0);

	alt_u8 *frame_pc = (alt_u8 *)(HEADER_RAM_BASE + 100);
	if ((memcmp(frame_pc + 12, "\x08\x06", 2) == 0) && frame_pc[21] == 0x02)
	{
		fl_proto = 0;  // Заглушка
    2744:	d0203005 	stb	zero,-32576(gp)

		memcpy(eth->mac_dest, (frame_pc + 22), 6);
    2748:	00029400 	call	2940 <memcpy>
//
//		// Frequency of send UDP-packet (3900 - 32000 frame per second)
//		timer_init(3890);
	}
	// && (memcmp(frame_pc + 30, ip->ip_src, 4) == 0) && frame_pc[23] == 0x1 && frame_pc[34] == 0x8
	if ((memcmp(frame_pc, "\xDE\xAD\xBE\xEF\xCA\xFE", 6) == 0))
    274c:	01400034 	movhi	r5,0
    2750:	01800184 	movi	r6,6
    2754:	294cf004 	addi	r5,r5,13248
    2758:	01159904 	movi	r4,22116
    275c:	00029100 	call	2910 <memcmp>
    2760:	10001526 	beq	r2,zero,27b8 <sgdma_rx_irq_handler+0xc8>
		while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor_header) != 0);

//		timer_init(0);
	}

	alt_dcache_flush_all();
    2764:	00029880 	call	2988 <alt_dcache_flush_all>
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
    2768:	01400034 	movhi	r5,0
    276c:	01000034 	movhi	r4,0
    2770:	000f883a 	mov	r7,zero
    2774:	01959904 	movi	r6,22116
    2778:	d8000015 	stw	zero,0(sp)
    277c:	294d5004 	addi	r5,r5,13632
    2780:	210d5804 	addi	r4,r4,13664
    2784:	00030380 	call	3038 <alt_avalon_sgdma_construct_stream_to_mem_desc>
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);
    2788:	d1203217 	ldw	r4,-32568(gp)
    278c:	01400034 	movhi	r5,0
    2790:	294d5804 	addi	r5,r5,13664
    2794:	0002c540 	call	2c54 <alt_avalon_sgdma_do_async_transfer>

	memset(frame_pc, 0, 100);
    2798:	01801904 	movi	r6,100
    279c:	000b883a 	mov	r5,zero
    27a0:	01159904 	movi	r4,22116
}
    27a4:	dfc00617 	ldw	ra,24(sp)
    27a8:	dc400517 	ldw	r17,20(sp)
    27ac:	dc000417 	ldw	r16,16(sp)
    27b0:	dec00704 	addi	sp,sp,28

	alt_dcache_flush_all();
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);

	memset(frame_pc, 0, 100);
    27b4:	00029681 	jmpi	2968 <memset>
//		timer_init(3890);
	}
	// && (memcmp(frame_pc + 30, ip->ip_src, 4) == 0) && frame_pc[23] == 0x1 && frame_pc[34] == 0x8
	if ((memcmp(frame_pc, "\xDE\xAD\xBE\xEF\xCA\xFE", 6) == 0))
	{
		alt_u16 length_descriptor = frame_pc[17] << 8 | frame_pc[16];
    27b8:	00959d44 	movi	r2,22133
    27bc:	14000003 	ldbu	r16,0(r2)
    27c0:	00959d04 	movi	r2,22132
    27c4:	10800003 	ldbu	r2,0(r2)
    27c8:	8020923a 	slli	r16,r16,8
		alt_u8 *pointer_to_data = frame_pc + 42;

		seq = frame_pc[40] << 8 | frame_pc[41];
		id = frame_pc[38] << 8 | frame_pc[39];

		create_icmp(icmp, id, seq, pointer_to_data);
    27cc:	0115a2c4 	movi	r4,22155
    27d0:	21400003 	ldbu	r5,0(r4)
//		timer_init(3890);
	}
	// && (memcmp(frame_pc + 30, ip->ip_src, 4) == 0) && frame_pc[23] == 0x1 && frame_pc[34] == 0x8
	if ((memcmp(frame_pc, "\xDE\xAD\xBE\xEF\xCA\xFE", 6) == 0))
	{
		alt_u16 length_descriptor = frame_pc[17] << 8 | frame_pc[16];
    27d4:	80a0b03a 	or	r16,r16,r2

		alt_u16 seq = 0;
		alt_u16 id = 0;
		alt_u8 *pointer_to_data = frame_pc + 42;

		seq = frame_pc[40] << 8 | frame_pc[41];
    27d8:	0095a304 	movi	r2,22156
		id = frame_pc[38] << 8 | frame_pc[39];

		create_icmp(icmp, id, seq, pointer_to_data);
    27dc:	10c00003 	ldbu	r3,0(r2)
    27e0:	0095a344 	movi	r2,22157
    27e4:	11800003 	ldbu	r6,0(r2)
		alt_u16 seq = 0;
		alt_u16 id = 0;
		alt_u8 *pointer_to_data = frame_pc + 42;

		seq = frame_pc[40] << 8 | frame_pc[41];
		id = frame_pc[38] << 8 | frame_pc[39];
    27e8:	0095a284 	movi	r2,22154

		create_icmp(icmp, id, seq, pointer_to_data);
    27ec:	10800003 	ldbu	r2,0(r2)
    27f0:	1806923a 	slli	r3,r3,8
    27f4:	d1200217 	ldw	r4,-32760(gp)
    27f8:	1004923a 	slli	r2,r2,8
    27fc:	198cb03a 	or	r6,r3,r6
    2800:	01d5a384 	movi	r7,22158
    2804:	114ab03a 	or	r5,r2,r5
    2808:	00026ac0 	call	26ac <create_icmp>

		create_ip(ip, 0x1, sizeof(icmp));
    280c:	d1200317 	ldw	r4,-32756(gp)
    2810:	04400044 	movi	r17,1
    2814:	01800104 	movi	r6,4
    2818:	880b883a 	mov	r5,r17
    281c:	00025780 	call	2578 <create_ip>

		alt_dcache_flush_all();
    2820:	00029880 	call	2988 <alt_dcache_flush_all>
		alt_avalon_sgdma_construct_mem_to_stream_desc(&tx_descriptor_header, &tx_descriptor_data, (alt_u32 *)HEADER_RAM_BASE, length_descriptor, 0, 1, 1, 0);
    2824:	81c00384 	addi	r7,r16,14
    2828:	01400034 	movhi	r5,0
    282c:	01000034 	movhi	r4,0
    2830:	294d6804 	addi	r5,r5,13728
    2834:	210d4804 	addi	r4,r4,13600
    2838:	d8000315 	stw	zero,12(sp)
    283c:	dc400215 	stw	r17,8(sp)
    2840:	dc400115 	stw	r17,4(sp)
    2844:	d8000015 	stw	zero,0(sp)
    2848:	39ffffcc 	andi	r7,r7,65535
    284c:	01958004 	movi	r6,22016
    2850:	00030b00 	call	30b0 <alt_avalon_sgdma_construct_mem_to_stream_desc>

		alt_avalon_sgdma_do_async_transfer(sgdma_tx_dev, &tx_descriptor_header);
    2854:	d1203117 	ldw	r4,-32572(gp)
    2858:	01400034 	movhi	r5,0
    285c:	294d4804 	addi	r5,r5,13600
    2860:	0002c540 	call	2c54 <alt_avalon_sgdma_do_async_transfer>
		while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor_header) != 0);
    2864:	01000034 	movhi	r4,0
    2868:	210d4804 	addi	r4,r4,13600
    286c:	0002d940 	call	2d94 <alt_avalon_sgdma_check_descriptor_status>
    2870:	103ffc1e 	bne	r2,zero,2864 <_gp+0xffff7428>
    2874:	003fbb06 	br	2764 <_gp+0xffff7328>

00002878 <pio_init>:
    return ~((temp >> 8) | (temp << 8));
}


void pio_init(void)
{
    2878:	defffe04 	addi	sp,sp,-8
    287c:	dfc00115 	stw	ra,4(sp)
	// Init PIO interrupt, 0b1 for 3 btn
	IOWR_ALTERA_AVALON_PIO_IRQ_MASK(ETH_IRQ_PIO_BASE, 0x1);
    2880:	00800044 	movi	r2,1
    2884:	00c00204 	movi	r3,8
    2888:	18800035 	stwio	r2,0(r3)
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ETH_IRQ_PIO_BASE, 0x1);
    288c:	00c00304 	movi	r3,12
    2890:	18800035 	stwio	r2,0(r3)

	// Register interrupt from PIO
	alt_ic_isr_register(ETH_IRQ_PIO_IRQ_INTERRUPT_CONTROLLER_ID, ETH_IRQ_PIO_IRQ, button_isr, 0, 0);
    2894:	01800034 	movhi	r6,0
    2898:	d8000015 	stw	zero,0(sp)
    289c:	000f883a 	mov	r7,zero
    28a0:	31887504 	addi	r6,r6,8660
    28a4:	01400104 	movi	r5,4
    28a8:	0009883a 	mov	r4,zero
    28ac:	00029a00 	call	29a0 <alt_ic_isr_register>
}
    28b0:	dfc00117 	ldw	ra,4(sp)
    28b4:	dec00204 	addi	sp,sp,8
    28b8:	f800283a 	ret

000028bc <main>:
alt_u8 fl_proto = 0;

/****************** Main block ******************/
int main(void)
{
	create_eth(eth);
    28bc:	d1200517 	ldw	r4,-32748(gp)
// Flag to set MAC-address of PC
alt_u8 fl_proto = 0;

/****************** Main block ******************/
int main(void)
{
    28c0:	defffe04 	addi	sp,sp,-8
    28c4:	dfc00115 	stw	ra,4(sp)
    28c8:	dc000015 	stw	r16,0(sp)
	create_eth(eth);
    28cc:	000247c0 	call	247c <create_eth>
	create_arp(arp, 0x0001);
    28d0:	d1200417 	ldw	r4,-32752(gp)
    28d4:	04000044 	movi	r16,1
    28d8:	800b883a 	mov	r5,r16
    28dc:	00024bc0 	call	24bc <create_arp>

	tse_init();
    28e0:	00022dc0 	call	22dc <tse_init>

	alt_u8 sdgma_status = open_sgdma();
    28e4:	00023e40 	call	23e4 <open_sgdma>
	if (sdgma_status == 1 || sdgma_status == 2) return(0);
    28e8:	10bfffc4 	addi	r2,r2,-1
    28ec:	10803fcc 	andi	r2,r2,255
    28f0:	8080022e 	bgeu	r16,r2,28fc <main+0x40>

	pio_init();
    28f4:	00028780 	call	2878 <pio_init>
    28f8:	003fff06 	br	28f8 <_gp+0xffff74bc>

	while (1);

	return 0;
}
    28fc:	0005883a 	mov	r2,zero
    2900:	dfc00117 	ldw	ra,4(sp)
    2904:	dc000017 	ldw	r16,0(sp)
    2908:	dec00204 	addi	sp,sp,8
    290c:	f800283a 	ret

00002910 <memcmp>:
    2910:	218d883a 	add	r6,r4,r6
    2914:	21800826 	beq	r4,r6,2938 <memcmp+0x28>
    2918:	20800003 	ldbu	r2,0(r4)
    291c:	28c00003 	ldbu	r3,0(r5)
    2920:	10c00226 	beq	r2,r3,292c <memcmp+0x1c>
    2924:	10c5c83a 	sub	r2,r2,r3
    2928:	f800283a 	ret
    292c:	21000044 	addi	r4,r4,1
    2930:	29400044 	addi	r5,r5,1
    2934:	003ff706 	br	2914 <_gp+0xffff74d8>
    2938:	0005883a 	mov	r2,zero
    293c:	f800283a 	ret

00002940 <memcpy>:
    2940:	2005883a 	mov	r2,r4
    2944:	2007883a 	mov	r3,r4
    2948:	218d883a 	add	r6,r4,r6
    294c:	19800526 	beq	r3,r6,2964 <memcpy+0x24>
    2950:	29000003 	ldbu	r4,0(r5)
    2954:	18c00044 	addi	r3,r3,1
    2958:	29400044 	addi	r5,r5,1
    295c:	193fffc5 	stb	r4,-1(r3)
    2960:	003ffa06 	br	294c <_gp+0xffff7510>
    2964:	f800283a 	ret

00002968 <memset>:
    2968:	2005883a 	mov	r2,r4
    296c:	2007883a 	mov	r3,r4
    2970:	218d883a 	add	r6,r4,r6
    2974:	19800326 	beq	r3,r6,2984 <memset+0x1c>
    2978:	19400005 	stb	r5,0(r3)
    297c:	18c00044 	addi	r3,r3,1
    2980:	003ffc06 	br	2974 <_gp+0xffff7538>
    2984:	f800283a 	ret

00002988 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
    2988:	0005883a 	mov	r2,zero
    298c:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
    2990:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
    2994:	10800804 	addi	r2,r2,32
    2998:	10fffd1e 	bne	r2,r3,2990 <_gp+0xffff7554>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
    299c:	f800283a 	ret

000029a0 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
    29a0:	0002a2c1 	jmpi	2a2c <alt_iic_isr_register>

000029a4 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    29a4:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    29a8:	00bfff84 	movi	r2,-2
    29ac:	2084703a 	and	r2,r4,r2
    29b0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    29b4:	00c00044 	movi	r3,1
    29b8:	d0a03317 	ldw	r2,-32564(gp)
    29bc:	194a983a 	sll	r5,r3,r5
    29c0:	288ab03a 	or	r5,r5,r2
    29c4:	d1603315 	stw	r5,-32564(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    29c8:	d0a03317 	ldw	r2,-32564(gp)
    29cc:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    29d0:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
    29d4:	0005883a 	mov	r2,zero
    29d8:	f800283a 	ret

000029dc <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    29dc:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    29e0:	00bfff84 	movi	r2,-2
    29e4:	2084703a 	and	r2,r4,r2
    29e8:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    29ec:	00ffff84 	movi	r3,-2
    29f0:	d0a03317 	ldw	r2,-32564(gp)
    29f4:	194a183a 	rol	r5,r3,r5
    29f8:	288a703a 	and	r5,r5,r2
    29fc:	d1603315 	stw	r5,-32564(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    2a00:	d0a03317 	ldw	r2,-32564(gp)
    2a04:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2a08:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
    2a0c:	0005883a 	mov	r2,zero
    2a10:	f800283a 	ret

00002a14 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
    2a14:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
    2a18:	00800044 	movi	r2,1
    2a1c:	1144983a 	sll	r2,r2,r5
    2a20:	10c4703a 	and	r2,r2,r3
}
    2a24:	1004c03a 	cmpne	r2,r2,zero
    2a28:	f800283a 	ret

00002a2c <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
    2a2c:	00c007c4 	movi	r3,31
    2a30:	19401616 	blt	r3,r5,2a8c <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    2a34:	defffe04 	addi	sp,sp,-8
    2a38:	dfc00115 	stw	ra,4(sp)
    2a3c:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2a40:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2a44:	00ffff84 	movi	r3,-2
    2a48:	80c6703a 	and	r3,r16,r3
    2a4c:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    2a50:	280490fa 	slli	r2,r5,3
    2a54:	00c00034 	movhi	r3,0
    2a58:	18cd7004 	addi	r3,r3,13760
    2a5c:	1885883a 	add	r2,r3,r2
    2a60:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
    2a64:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    2a68:	30000226 	beq	r6,zero,2a74 <alt_iic_isr_register+0x48>
    2a6c:	00029a40 	call	29a4 <alt_ic_irq_enable>
    2a70:	00000106 	br	2a78 <alt_iic_isr_register+0x4c>
    2a74:	00029dc0 	call	29dc <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2a78:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
    2a7c:	dfc00117 	ldw	ra,4(sp)
    2a80:	dc000017 	ldw	r16,0(sp)
    2a84:	dec00204 	addi	sp,sp,8
    2a88:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
    2a8c:	00bffa84 	movi	r2,-22
    2a90:	f800283a 	ret

00002a94 <alt_load>:
    2a94:	deffff04 	addi	sp,sp,-4
    2a98:	01000034 	movhi	r4,0
    2a9c:	01400034 	movhi	r5,0
    2aa0:	dfc00015 	stw	ra,0(sp)
    2aa4:	210cf704 	addi	r4,r4,13276
    2aa8:	294d1b04 	addi	r5,r5,13420
    2aac:	2140061e 	bne	r4,r5,2ac8 <alt_load+0x34>
    2ab0:	01000034 	movhi	r4,0
    2ab4:	01400034 	movhi	r5,0
    2ab8:	21080804 	addi	r4,r4,8224
    2abc:	29480804 	addi	r5,r5,8224
    2ac0:	2140121e 	bne	r4,r5,2b0c <alt_load+0x78>
    2ac4:	00000b06 	br	2af4 <alt_load+0x60>
    2ac8:	00c00034 	movhi	r3,0
    2acc:	18cd1b04 	addi	r3,r3,13420
    2ad0:	1907c83a 	sub	r3,r3,r4
    2ad4:	0005883a 	mov	r2,zero
    2ad8:	10fff526 	beq	r2,r3,2ab0 <_gp+0xffff7674>
    2adc:	114f883a 	add	r7,r2,r5
    2ae0:	39c00017 	ldw	r7,0(r7)
    2ae4:	110d883a 	add	r6,r2,r4
    2ae8:	10800104 	addi	r2,r2,4
    2aec:	31c00015 	stw	r7,0(r6)
    2af0:	003ff906 	br	2ad8 <_gp+0xffff769c>
    2af4:	01000034 	movhi	r4,0
    2af8:	01400034 	movhi	r5,0
    2afc:	210ce804 	addi	r4,r4,13216
    2b00:	294ce804 	addi	r5,r5,13216
    2b04:	2140101e 	bne	r4,r5,2b48 <alt_load+0xb4>
    2b08:	00000b06 	br	2b38 <alt_load+0xa4>
    2b0c:	00c00034 	movhi	r3,0
    2b10:	18c86204 	addi	r3,r3,8584
    2b14:	1907c83a 	sub	r3,r3,r4
    2b18:	0005883a 	mov	r2,zero
    2b1c:	10fff526 	beq	r2,r3,2af4 <_gp+0xffff76b8>
    2b20:	114f883a 	add	r7,r2,r5
    2b24:	39c00017 	ldw	r7,0(r7)
    2b28:	110d883a 	add	r6,r2,r4
    2b2c:	10800104 	addi	r2,r2,4
    2b30:	31c00015 	stw	r7,0(r6)
    2b34:	003ff906 	br	2b1c <_gp+0xffff76e0>
    2b38:	00029880 	call	2988 <alt_dcache_flush_all>
    2b3c:	dfc00017 	ldw	ra,0(sp)
    2b40:	dec00104 	addi	sp,sp,4
    2b44:	00032c41 	jmpi	32c4 <alt_icache_flush_all>
    2b48:	00c00034 	movhi	r3,0
    2b4c:	18ccf704 	addi	r3,r3,13276
    2b50:	1907c83a 	sub	r3,r3,r4
    2b54:	0005883a 	mov	r2,zero
    2b58:	18bff726 	beq	r3,r2,2b38 <_gp+0xffff76fc>
    2b5c:	114f883a 	add	r7,r2,r5
    2b60:	39c00017 	ldw	r7,0(r7)
    2b64:	110d883a 	add	r6,r2,r4
    2b68:	10800104 	addi	r2,r2,4
    2b6c:	31c00015 	stw	r7,0(r6)
    2b70:	003ff906 	br	2b58 <_gp+0xffff771c>

00002b74 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    2b74:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2b78:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    2b7c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2b80:	0002ba00 	call	2ba0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    2b84:	0002bc00 	call	2bc0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2b88:	d1a03417 	ldw	r6,-32560(gp)
    2b8c:	d1603517 	ldw	r5,-32556(gp)
    2b90:	d1203617 	ldw	r4,-32552(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    2b94:	dfc00017 	ldw	ra,0(sp)
    2b98:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2b9c:	00028bc1 	jmpi	28bc <main>

00002ba0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    2ba0:	deffff04 	addi	sp,sp,-4
    2ba4:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
    2ba8:	00033440 	call	3344 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    2bac:	00800044 	movi	r2,1
    2bb0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    2bb4:	dfc00017 	ldw	ra,0(sp)
    2bb8:	dec00104 	addi	sp,sp,4
    2bbc:	f800283a 	ret

00002bc0 <alt_sys_init>:

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    2bc0:	01000034 	movhi	r4,0
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    2bc4:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    2bc8:	000d883a 	mov	r6,zero
    2bcc:	000b883a 	mov	r5,zero
    2bd0:	210d0304 	addi	r4,r4,13324
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    2bd4:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    2bd8:	00031380 	call	3138 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( TX_DMA, tx_dma);
    2bdc:	01000034 	movhi	r4,0
    2be0:	01800044 	movi	r6,1
    2be4:	000b883a 	mov	r5,zero
    2be8:	210cf704 	addi	r4,r4,13276
    ALTERA_ETH_TSE_INIT ( TSE, tse);
}
    2bec:	dfc00017 	ldw	ra,0(sp)
    2bf0:	dec00104 	addi	sp,sp,4
void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    ALTERA_AVALON_SGDMA_INIT ( TX_DMA, tx_dma);
    2bf4:	00031381 	jmpi	3138 <alt_avalon_sgdma_init>

00002bf8 <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
    2bf8:	20800317 	ldw	r2,12(r4)
    2bfc:	10800404 	addi	r2,r2,16
    2c00:	10c00037 	ldwio	r3,0(r2)
    2c04:	18e00034 	orhi	r3,r3,32768
    2c08:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2c0c:	20800317 	ldw	r2,12(r4)
    2c10:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    2c14:	20c00917 	ldw	r3,36(r4)
    2c18:	18000d26 	beq	r3,zero,2c50 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
    2c1c:	defffe04 	addi	sp,sp,-8
    2c20:	dfc00115 	stw	ra,4(sp)
    2c24:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2c28:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2c2c:	00bfff84 	movi	r2,-2
    2c30:	8084703a 	and	r2,r16,r2
    2c34:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
    2c38:	21000a17 	ldw	r4,40(r4)
    2c3c:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2c40:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
    2c44:	dfc00117 	ldw	ra,4(sp)
    2c48:	dc000017 	ldw	r16,0(sp)
    2c4c:	dec00204 	addi	sp,sp,8
    2c50:	f800283a 	ret

00002c54 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
    2c54:	20c00317 	ldw	r3,12(r4)
    2c58:	18800037 	ldwio	r2,0(r3)
    2c5c:	1080040c 	andi	r2,r2,16
    2c60:	1000191e 	bne	r2,zero,2cc8 <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2c64:	18c00404 	addi	r3,r3,16
    2c68:	19c00037 	ldwio	r7,0(r3)
    2c6c:	01bff7c4 	movi	r6,-33
    2c70:	398c703a 	and	r6,r7,r6
    2c74:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2c78:	20c00317 	ldw	r3,12(r4)
    2c7c:	01803fc4 	movi	r6,255
    2c80:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
    2c84:	20c00317 	ldw	r3,12(r4)
    2c88:	19400835 	stwio	r5,32(r3)
    2c8c:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
    2c90:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2c94:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
    2c98:	28000526 	beq	r5,zero,2cb0 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2c9c:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2ca0:	21000b17 	ldw	r4,44(r4)
    2ca4:	21001814 	ori	r4,r4,96
    2ca8:	2148b03a 	or	r4,r4,r5
    2cac:	00000406 	br	2cc0 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2cb0:	19400037 	ldwio	r5,0(r3)
    2cb4:	013ffbc4 	movi	r4,-17
    2cb8:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2cbc:	21001814 	ori	r4,r4,96
    2cc0:	19000035 	stwio	r4,0(r3)
    2cc4:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
    2cc8:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
    2ccc:	f800283a 	ret

00002cd0 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
    2cd0:	20c00317 	ldw	r3,12(r4)
    2cd4:	18800037 	ldwio	r2,0(r3)
    2cd8:	1080040c 	andi	r2,r2,16
    2cdc:	103ffc1e 	bne	r2,zero,2cd0 <_gp+0xffff7894>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2ce0:	18c00404 	addi	r3,r3,16
    2ce4:	19800037 	ldwio	r6,0(r3)
    2ce8:	00bff7c4 	movi	r2,-33
    2cec:	308c703a 	and	r6,r6,r2
    2cf0:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2cf4:	20c00317 	ldw	r3,12(r4)
    2cf8:	01803fc4 	movi	r6,255
    2cfc:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
    2d00:	20c00317 	ldw	r3,12(r4)
    2d04:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2d08:	20c00317 	ldw	r3,12(r4)
    2d0c:	18c00404 	addi	r3,r3,16
    2d10:	19400037 	ldwio	r5,0(r3)
    2d14:	29401814 	ori	r5,r5,96
    2d18:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
    2d1c:	20c00317 	ldw	r3,12(r4)
    2d20:	19400037 	ldwio	r5,0(r3)
    2d24:	2940040c 	andi	r5,r5,16
    2d28:	283ffc1e 	bne	r5,zero,2d1c <_gp+0xffff78e0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
    2d2c:	18c00404 	addi	r3,r3,16
    2d30:	19400037 	ldwio	r5,0(r3)
    2d34:	2884703a 	and	r2,r5,r2
    2d38:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
    2d3c:	20c00317 	ldw	r3,12(r4)
    2d40:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2d44:	01003fc4 	movi	r4,255
    2d48:	19000035 	stwio	r4,0(r3)

  return status;
}
    2d4c:	f800283a 	ret

00002d50 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
    2d50:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
    2d54:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
    2d58:	21800b15 	stw	r6,44(r4)
    2d5c:	f800283a 	ret

00002d60 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2d60:	20800317 	ldw	r2,12(r4)
    2d64:	10800404 	addi	r2,r2,16
    2d68:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2d6c:	18c00814 	ori	r3,r3,32
    2d70:	10c00035 	stwio	r3,0(r2)
    2d74:	f800283a 	ret

00002d78 <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2d78:	20800317 	ldw	r2,12(r4)
    2d7c:	10800404 	addi	r2,r2,16
    2d80:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2d84:	00fff7c4 	movi	r3,-33
    2d88:	20c6703a 	and	r3,r4,r3
    2d8c:	10c00035 	stwio	r3,0(r2)
    2d90:	f800283a 	ret

00002d94 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
    2d94:	208007a3 	ldbuio	r2,30(r4)
    2d98:	10801fcc 	andi	r2,r2,127
    2d9c:	1000041e 	bne	r2,zero,2db0 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
    2da0:	208007e3 	ldbuio	r2,31(r4)
    2da4:	1080200c 	andi	r2,r2,128
    2da8:	1000031e 	bne	r2,zero,2db8 <alt_avalon_sgdma_check_descriptor_status+0x24>
    2dac:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
    2db0:	00bffec4 	movi	r2,-5
    2db4:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
    2db8:	00bfe244 	movi	r2,-119
  }

    return 0;
}
    2dbc:	f800283a 	ret

00002dc0 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
    2dc0:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
    2dc4:	d1600904 	addi	r5,gp,-32732
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
    2dc8:	dc000015 	stw	r16,0(sp)
    2dcc:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
    2dd0:	00032500 	call	3250 <alt_find_dev>
    2dd4:	1021883a 	mov	r16,r2

  if (NULL == dev) {
    2dd8:	1000071e 	bne	r2,zero,2df8 <alt_avalon_sgdma_open+0x38>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
    2ddc:	d0a00b17 	ldw	r2,-32724(gp)
    2de0:	10000226 	beq	r2,zero,2dec <alt_avalon_sgdma_open+0x2c>
    2de4:	103ee83a 	callr	r2
    2de8:	00000106 	br	2df0 <alt_avalon_sgdma_open+0x30>
    2dec:	d0a03804 	addi	r2,gp,-32544
    ALT_ERRNO = ENODEV;
    2df0:	00c004c4 	movi	r3,19
    2df4:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
    2df8:	8005883a 	mov	r2,r16
    2dfc:	dfc00117 	ldw	ra,4(sp)
    2e00:	dc000017 	ldw	r16,0(sp)
    2e04:	dec00204 	addi	sp,sp,8
    2e08:	f800283a 	ret

00002e0c <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2e0c:	20c00317 	ldw	r3,12(r4)
    2e10:	18c00404 	addi	r3,r3,16
    2e14:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
    2e18:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2e1c:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
    2e20:	10bfffc4 	addi	r2,r2,-1
    2e24:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2e28:	295ffc2c 	andhi	r5,r5,32752
    2e2c:	29400134 	orhi	r5,r5,4
    2e30:	288ab03a 	or	r5,r5,r2
    2e34:	19400035 	stwio	r5,0(r3)
    2e38:	f800283a 	ret

00002e3c <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2e3c:	20800317 	ldw	r2,12(r4)
    2e40:	10800404 	addi	r2,r2,16
    2e44:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2e48:	00ffff34 	movhi	r3,65532
    2e4c:	18ffffc4 	addi	r3,r3,-1
    2e50:	20c6703a 	and	r3,r4,r3
    2e54:	10c00035 	stwio	r3,0(r2)
    2e58:	f800283a 	ret

00002e5c <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    2e5c:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
    2e60:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    2e64:	10801fcc 	andi	r2,r2,127
    2e68:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2e6c:	3004d23a 	srli	r2,r6,8
    2e70:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
    2e74:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2e78:	20800045 	stb	r2,1(r4)
    2e7c:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2e80:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2e84:	300cd63a 	srli	r6,r6,24
    2e88:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
    2e8c:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2e90:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
    2e94:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
    2e98:	20800245 	stb	r2,9(r4)
    2e9c:	3804d43a 	srli	r2,r7,16
    2ea0:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
    2ea4:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
    2ea8:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
    2eac:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
    2eb0:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
    2eb4:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2eb8:	20800445 	stb	r2,17(r4)
    2ebc:	2804d43a 	srli	r2,r5,16
    2ec0:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
    2ec4:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2ec8:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
    2ecc:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2ed0:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
    2ed4:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
    2ed8:	20800605 	stb	r2,24(r4)
    2edc:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
    2ee0:	20000345 	stb	zero,13(r4)
    2ee4:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
    2ee8:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
    2eec:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
    2ef0:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
    2ef4:	20000505 	stb	zero,20(r4)
    2ef8:	20000545 	stb	zero,21(r4)
    2efc:	20000585 	stb	zero,22(r4)
    2f00:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
    2f04:	20000705 	stb	zero,28(r4)
    2f08:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
    2f0c:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
    2f10:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
    2f14:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
    2f18:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
    2f1c:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
    2f20:	d8800217 	ldw	r2,8(sp)
    2f24:	280ac03a 	cmpne	r5,r5,zero
    2f28:	297fe004 	addi	r5,r5,-128
    2f2c:	1004c03a 	cmpne	r2,r2,zero
    2f30:	1004907a 	slli	r2,r2,1
    2f34:	2884b03a 	or	r2,r5,r2
    2f38:	d9400317 	ldw	r5,12(sp)
    2f3c:	280ac03a 	cmpne	r5,r5,zero
    2f40:	280a90ba 	slli	r5,r5,2
    2f44:	114ab03a 	or	r5,r2,r5
    2f48:	18803fcc 	andi	r2,r3,255
    2f4c:	10000326 	beq	r2,zero,2f5c <alt_avalon_sgdma_construct_descriptor_burst+0x100>
    2f50:	18c003cc 	andi	r3,r3,15
    2f54:	180490fa 	slli	r2,r3,3
    2f58:	00000106 	br	2f60 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
    2f5c:	0005883a 	mov	r2,zero
    2f60:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
    2f64:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
    2f68:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
    2f6c:	00031bc1 	jmpi	31bc <alt_dcache_flush>

00002f70 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
    2f70:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
    2f74:	d8800c17 	ldw	r2,48(sp)
    2f78:	d8000615 	stw	zero,24(sp)
    2f7c:	d8000115 	stw	zero,4(sp)
    2f80:	d8800515 	stw	r2,20(sp)
    2f84:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
    2f88:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
    2f8c:	d8800415 	stw	r2,16(sp)
    2f90:	d8800a17 	ldw	r2,40(sp)
    2f94:	d8800315 	stw	r2,12(sp)
    2f98:	d8800917 	ldw	r2,36(sp)
    2f9c:	d8800215 	stw	r2,8(sp)
    2fa0:	d880080b 	ldhu	r2,32(sp)
    2fa4:	d8800015 	stw	r2,0(sp)
    2fa8:	0002e5c0 	call	2e5c <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
    2fac:	dfc00717 	ldw	ra,28(sp)
    2fb0:	dec00804 	addi	sp,sp,32
    2fb4:	f800283a 	ret

00002fb8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
    2fb8:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
    2fbc:	d8800817 	ldw	r2,32(sp)
    2fc0:	d8000415 	stw	zero,16(sp)
    2fc4:	d8000315 	stw	zero,12(sp)
    2fc8:	d8800215 	stw	r2,8(sp)
    2fcc:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
    2fd0:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
    2fd4:	d8800115 	stw	r2,4(sp)
    2fd8:	d880060b 	ldhu	r2,24(sp)
    2fdc:	d8800015 	stw	r2,0(sp)
    2fe0:	0002f700 	call	2f70 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
    2fe4:	dfc00517 	ldw	ra,20(sp)
    2fe8:	dec00604 	addi	sp,sp,24
    2fec:	f800283a 	ret

00002ff0 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
    2ff0:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
    2ff4:	d8800917 	ldw	r2,36(sp)
    2ff8:	39ffffcc 	andi	r7,r7,65535
    2ffc:	d9c00015 	stw	r7,0(sp)
    3000:	d8800515 	stw	r2,20(sp)
    3004:	d8800817 	ldw	r2,32(sp)
    3008:	300f883a 	mov	r7,r6
    300c:	d8000615 	stw	zero,24(sp)
    3010:	d8000415 	stw	zero,16(sp)
    3014:	d8800315 	stw	r2,12(sp)
    3018:	d8000215 	stw	zero,8(sp)
    301c:	d8000115 	stw	zero,4(sp)
    3020:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
    3024:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
    3028:	0002e5c0 	call	2e5c <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
    302c:	dfc00717 	ldw	ra,28(sp)
    3030:	dec00804 	addi	sp,sp,32
    3034:	f800283a 	ret

00003038 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
    3038:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
    303c:	d8800317 	ldw	r2,12(sp)
    3040:	d8000115 	stw	zero,4(sp)
    3044:	39ffffcc 	andi	r7,r7,65535
    3048:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
    304c:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
    3050:	0002ff00 	call	2ff0 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
    3054:	dfc00217 	ldw	ra,8(sp)
    3058:	dec00304 	addi	sp,sp,12
    305c:	f800283a 	ret

00003060 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
    3060:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
    3064:	d8800c03 	ldbu	r2,48(sp)
    3068:	39ffffcc 	andi	r7,r7,65535
    306c:	d9c00015 	stw	r7,0(sp)
    3070:	d8800615 	stw	r2,24(sp)
    3074:	d8800b17 	ldw	r2,44(sp)
    3078:	d8000515 	stw	zero,20(sp)
    307c:	000f883a 	mov	r7,zero
    3080:	d8800415 	stw	r2,16(sp)
    3084:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
    3088:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
    308c:	d8800315 	stw	r2,12(sp)
    3090:	d8800817 	ldw	r2,32(sp)
    3094:	d8800215 	stw	r2,8(sp)
    3098:	d8800a17 	ldw	r2,40(sp)
    309c:	d8800115 	stw	r2,4(sp)
    30a0:	0002e5c0 	call	2e5c <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
    30a4:	dfc00717 	ldw	ra,28(sp)
    30a8:	dec00804 	addi	sp,sp,32
    30ac:	f800283a 	ret

000030b0 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
    30b0:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
    30b4:	d8800903 	ldbu	r2,36(sp)
    30b8:	d8000315 	stw	zero,12(sp)
    30bc:	39ffffcc 	andi	r7,r7,65535
    30c0:	d8800415 	stw	r2,16(sp)
    30c4:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
    30c8:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
    30cc:	d8800215 	stw	r2,8(sp)
    30d0:	d8800717 	ldw	r2,28(sp)
    30d4:	d8800115 	stw	r2,4(sp)
    30d8:	d8800617 	ldw	r2,24(sp)
    30dc:	d8800015 	stw	r2,0(sp)
    30e0:	00030600 	call	3060 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
    30e4:	dfc00517 	ldw	ra,20(sp)
    30e8:	dec00604 	addi	sp,sp,24
    30ec:	f800283a 	ret

000030f0 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
    30f0:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
    30f4:	d8800c03 	ldbu	r2,48(sp)
    30f8:	d8000515 	stw	zero,20(sp)
    30fc:	d8000415 	stw	zero,16(sp)
    3100:	d8800615 	stw	r2,24(sp)
    3104:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
    3108:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
    310c:	d8800315 	stw	r2,12(sp)
    3110:	d8800a17 	ldw	r2,40(sp)
    3114:	d8800215 	stw	r2,8(sp)
    3118:	d8800917 	ldw	r2,36(sp)
    311c:	d8800115 	stw	r2,4(sp)
    3120:	d880080b 	ldhu	r2,32(sp)
    3124:	d8800015 	stw	r2,0(sp)
    3128:	0002e5c0 	call	2e5c <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
    312c:	dfc00717 	ldw	ra,28(sp)
    3130:	dec00804 	addi	sp,sp,32
    3134:	f800283a 	ret

00003138 <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    3138:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
    313c:	defffb04 	addi	sp,sp,-20
    3140:	dc800315 	stw	r18,12(sp)
    3144:	dc400215 	stw	r17,8(sp)
    3148:	dc000115 	stw	r16,4(sp)
    314c:	dfc00415 	stw	ra,16(sp)
    3150:	2021883a 	mov	r16,r4
    3154:	2823883a 	mov	r17,r5
    3158:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    315c:	00800074 	movhi	r2,1
    3160:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    3164:	20c00317 	ldw	r3,12(r4)
    3168:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
    316c:	20800317 	ldw	r2,12(r4)
    3170:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    3174:	20800317 	ldw	r2,12(r4)
    3178:	00c03fc4 	movi	r3,255
    317c:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
    3180:	d1600904 	addi	r5,gp,-32732
    3184:	00031e40 	call	31e4 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
    3188:	01800034 	movhi	r6,0
    318c:	d8000015 	stw	zero,0(sp)
    3190:	800f883a 	mov	r7,r16
    3194:	318afe04 	addi	r6,r6,11256
    3198:	900b883a 	mov	r5,r18
    319c:	8809883a 	mov	r4,r17
    31a0:	00029a00 	call	29a0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
    31a4:	dfc00417 	ldw	ra,16(sp)
    31a8:	dc800317 	ldw	r18,12(sp)
    31ac:	dc400217 	ldw	r17,8(sp)
    31b0:	dc000117 	ldw	r16,4(sp)
    31b4:	dec00504 	addi	sp,sp,20
    31b8:	f800283a 	ret

000031bc <alt_dcache_flush>:
void alt_dcache_flush (void* start, alt_u32 len)
{
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
    31bc:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
    31c0:	2005883a 	mov	r2,r4
    31c4:	1140032e 	bgeu	r2,r5,31d4 <alt_dcache_flush+0x18>
  { 
    ALT_FLUSH_DATA(i); 
    31c8:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
    31cc:	10800804 	addi	r2,r2,32
    31d0:	003ffc06 	br	31c4 <_gp+0xffff7d88>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
    31d4:	210007cc 	andi	r4,r4,31
    31d8:	20000126 	beq	r4,zero,31e0 <alt_dcache_flush+0x24>
  {
    ALT_FLUSH_DATA(i);
    31dc:	1000001b 	flushda	0(r2)
    31e0:	f800283a 	ret

000031e4 <alt_dev_llist_insert>:
    31e4:	20000226 	beq	r4,zero,31f0 <alt_dev_llist_insert+0xc>
    31e8:	20800217 	ldw	r2,8(r4)
    31ec:	1000101e 	bne	r2,zero,3230 <alt_dev_llist_insert+0x4c>
    31f0:	d0a00b17 	ldw	r2,-32724(gp)
    31f4:	10000926 	beq	r2,zero,321c <alt_dev_llist_insert+0x38>
    31f8:	deffff04 	addi	sp,sp,-4
    31fc:	dfc00015 	stw	ra,0(sp)
    3200:	103ee83a 	callr	r2
    3204:	00c00584 	movi	r3,22
    3208:	10c00015 	stw	r3,0(r2)
    320c:	00bffa84 	movi	r2,-22
    3210:	dfc00017 	ldw	ra,0(sp)
    3214:	dec00104 	addi	sp,sp,4
    3218:	f800283a 	ret
    321c:	d0a03804 	addi	r2,gp,-32544
    3220:	00c00584 	movi	r3,22
    3224:	10c00015 	stw	r3,0(r2)
    3228:	00bffa84 	movi	r2,-22
    322c:	f800283a 	ret
    3230:	28800017 	ldw	r2,0(r5)
    3234:	21400115 	stw	r5,4(r4)
    3238:	20800015 	stw	r2,0(r4)
    323c:	28800017 	ldw	r2,0(r5)
    3240:	11000115 	stw	r4,4(r2)
    3244:	29000015 	stw	r4,0(r5)
    3248:	0005883a 	mov	r2,zero
    324c:	f800283a 	ret

00003250 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
    3250:	defffb04 	addi	sp,sp,-20
    3254:	dcc00315 	stw	r19,12(sp)
    3258:	dc800215 	stw	r18,8(sp)
    325c:	dc400115 	stw	r17,4(sp)
    3260:	dc000015 	stw	r16,0(sp)
    3264:	dfc00415 	stw	ra,16(sp)
    3268:	2027883a 	mov	r19,r4
    326c:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
    3270:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
    3274:	00033840 	call	3384 <strlen>
    3278:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
    327c:	84400726 	beq	r16,r17,329c <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
    3280:	81000217 	ldw	r4,8(r16)
    3284:	900d883a 	mov	r6,r18
    3288:	980b883a 	mov	r5,r19
    328c:	00029100 	call	2910 <memcmp>
    3290:	10000426 	beq	r2,zero,32a4 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
    3294:	84000017 	ldw	r16,0(r16)
    3298:	003ff806 	br	327c <_gp+0xffff7e40>
  }
  
  /* No match found */
  
  return NULL;
    329c:	0005883a 	mov	r2,zero
    32a0:	00000106 	br	32a8 <alt_find_dev+0x58>
    32a4:	8005883a 	mov	r2,r16
}
    32a8:	dfc00417 	ldw	ra,16(sp)
    32ac:	dcc00317 	ldw	r19,12(sp)
    32b0:	dc800217 	ldw	r18,8(sp)
    32b4:	dc400117 	ldw	r17,4(sp)
    32b8:	dc000017 	ldw	r16,0(sp)
    32bc:	dec00504 	addi	sp,sp,20
    32c0:	f800283a 	ret

000032c4 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
    32c4:	01440004 	movi	r5,4096
    32c8:	0009883a 	mov	r4,zero
    32cc:	000334c1 	jmpi	334c <alt_icache_flush>

000032d0 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
    32d0:	213ffe84 	addi	r4,r4,-6
    32d4:	008003c4 	movi	r2,15
    32d8:	11001636 	bltu	r2,r4,3334 <alt_exception_cause_generated_bad_addr+0x64>
    32dc:	200890ba 	slli	r4,r4,2
    32e0:	00800034 	movhi	r2,0
    32e4:	108cbd04 	addi	r2,r2,13044
    32e8:	2089883a 	add	r4,r4,r2
    32ec:	20800017 	ldw	r2,0(r4)
    32f0:	1000683a 	jmp	r2
    32f4:	0000333c 	xorhi	zero,zero,204
    32f8:	0000333c 	xorhi	zero,zero,204
    32fc:	00003334 	movhi	zero,204
    3300:	00003334 	movhi	zero,204
    3304:	00003334 	movhi	zero,204
    3308:	0000333c 	xorhi	zero,zero,204
    330c:	00003334 	movhi	zero,204
    3310:	00003334 	movhi	zero,204
    3314:	0000333c 	xorhi	zero,zero,204
    3318:	0000333c 	xorhi	zero,zero,204
    331c:	00003334 	movhi	zero,204
    3320:	0000333c 	xorhi	zero,zero,204
    3324:	00003334 	movhi	zero,204
    3328:	00003334 	movhi	zero,204
    332c:	00003334 	movhi	zero,204
    3330:	0000333c 	xorhi	zero,zero,204
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
    3334:	0005883a 	mov	r2,zero
    3338:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
    333c:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
    3340:	f800283a 	ret

00003344 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    3344:	000170fa 	wrctl	ienable,zero
    3348:	f800283a 	ret

0000334c <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
    334c:	00840004 	movi	r2,4096
    3350:	1140012e 	bgeu	r2,r5,3358 <alt_icache_flush+0xc>
    3354:	100b883a 	mov	r5,r2
    3358:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    335c:	2005883a 	mov	r2,r4
    3360:	1140032e 	bgeu	r2,r5,3370 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
    3364:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    3368:	10800804 	addi	r2,r2,32
    336c:	003ffc06 	br	3360 <_gp+0xffff7f24>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
    3370:	210007cc 	andi	r4,r4,31
    3374:	20000126 	beq	r4,zero,337c <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
    3378:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
    337c:	0000203a 	flushp
    3380:	f800283a 	ret

00003384 <strlen>:
    3384:	2005883a 	mov	r2,r4
    3388:	10c00007 	ldb	r3,0(r2)
    338c:	18000226 	beq	r3,zero,3398 <strlen+0x14>
    3390:	10800044 	addi	r2,r2,1
    3394:	003ffc06 	br	3388 <_gp+0xffff7f4c>
    3398:	1105c83a 	sub	r2,r2,r4
    339c:	f800283a 	ret
