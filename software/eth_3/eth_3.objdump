
eth_3.elf:     file format elf32-littlenios2
eth_3.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00002188

Program Header:
    LOAD off    0x00001000 vaddr 0x00002000 paddr 0x00002000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00002020 paddr 0x00002020 align 2**12
         filesz 0x00001248 memsz 0x00001248 flags r-x
    LOAD off    0x00002268 vaddr 0x00003268 paddr 0x000032fc align 2**12
         filesz 0x00000094 memsz 0x00000094 flags rw-
    LOAD off    0x00002390 vaddr 0x00003390 paddr 0x00003390 align 2**12
         filesz 0x00000000 memsz 0x000001c0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00002000  00002000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000168  00002020  00002020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000010a8  00002188  00002188  00001188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000038  00003230  00003230  00002230  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000094  00003268  000032fc  00002268  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000001c0  00003390  00003390  00002390  2**2
                  ALLOC, SMALL_DATA
  6 .system_ram   00000000  00003550  00003550  000022fc  2**0
                  CONTENTS
  7 .rx_buf_ram   00000000  00005400  00005400  000022fc  2**0
                  CONTENTS
  8 .header_ram   00000000  00005600  00005600  000022fc  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  000022fc  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000368  00000000  00000000  00002320  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00003927  00000000  00000000  00002688  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000156d  00000000  00000000  00005faf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00001670  00000000  00000000  0000751c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000638  00000000  00000000  00008b8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00001586  00000000  00000000  000091c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000166a  00000000  00000000  0000a74a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000030  00000000  00000000  0000bdb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000170  00000000  00000000  0000bde8  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  0000d8c2  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000c  00000000  00000000  0000d8c5  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0000d8d1  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0000d8d2  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   0000000b  00000000  00000000  0000d8d3  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    0000000b  00000000  00000000  0000d8de  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   0000000b  00000000  00000000  0000d8e9  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000b  00000000  00000000  0000d8f4  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000031  00000000  00000000  0000d8ff  2**0
                  CONTENTS, READONLY
 28 .jdi          00005554  00000000  00000000  0000d930  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     00084bcf  00000000  00000000  00012e84  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 .entry
00002020 l    d  .exceptions	00000000 .exceptions
00002188 l    d  .text	00000000 .text
00003230 l    d  .rodata	00000000 .rodata
00003268 l    d  .rwdata	00000000 .rwdata
00003390 l    d  .bss	00000000 .bss
00003550 l    d  .system_ram	00000000 .system_ram
00005400 l    d  .rx_buf_ram	00000000 .rx_buf_ram
00005600 l    d  .header_ram	00000000 .header_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../eth_3_bsp//obj/HAL/src/crt0.o
000021d0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00003298 l     O .rwdata	00000030 rx_dma
00003268 l     O .rwdata	00000030 tx_dma
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
00002a58 l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
000033a8 g     O .bss	00000004 alt_instruction_exception_handler
000029d4 g     F .text	0000002c alt_main
00003450 g     O .bss	00000100 alt_irq
000032fc g       *ABS*	00000000 __flash_rwdata_start
00002b30 g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
00005600 g       *ABS*	00000000 __alt_mem_header_ram
000032d8 g     O .rwdata	00000004 ip
00002cbc g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
000031a4 g     F .text	00000008 altera_nios2_gen2_irq_init
00002000 g     F .entry	0000001c __reset
00002e50 g     F .text	00000048 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00002020 g       *ABS*	00000000 __flash_exceptions_start
000033ac g     O .bss	00000004 errno
000026f0 g     F .text	00000044 pio_init
00002578 g     F .text	00000094 create_ip
000033a0 g     O .bss	00000004 alt_argv
0000b2c8 g       *ABS*	00000000 _gp
000023e4 g     F .text	00000098 open_sgdma
00002278 g     F .text	00000064 sgdma_rx_irq_handler
000030b0 g     F .text	00000074 alt_find_dev
000027a0 g     F .text	00000028 memcpy
000032c8 g     O .rwdata	00000001 fl_proto
00003130 g     F .text	00000074 alt_exception_cause_generated_bad_addr
00002ec0 g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
000032d0 g     O .rwdata	00000004 udp
000032cc g     O .rwdata	00000004 tse
000031ac g     F .text	00000038 alt_icache_flush
000032e0 g     O .rwdata	00000004 eth
00005400 g       *ABS*	00000000 __alt_mem_rx_buf_ram
000033b0 g     O .bss	00000020 tx_descriptor_header
00002bd8 g     F .text	0000001c alt_avalon_sgdma_stop
000032dc g     O .rwdata	00000004 arp
0000301c g     F .text	00000028 alt_dcache_flush
00003550 g       *ABS*	00000000 __bss_end
0000288c g     F .text	00000068 alt_iic_isr_register
00002ab4 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
000033d0 g     O .bss	00000020 rx_descriptor_end
00002874 g     F .text	00000018 alt_ic_irq_enabled
00003398 g     O .bss	00000004 alt_irq_active
000020fc g     F .exceptions	00000060 alt_irq_handler
00002bf4 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
00002000 g       *ABS*	00000000 __alt_mem_system_ram
000027e8 g     F .text	00000018 alt_dcache_flush_all
000033f0 g     O .bss	00000020 rx_descriptor
000032fc g       *ABS*	00000000 __ram_rwdata_end
00002c6c g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
00003268 g       *ABS*	00000000 __ram_rodata_end
000032ec g     O .rwdata	00000004 jtag_uart_0
00002f10 g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
00002bb0 g     F .text	00000010 alt_avalon_sgdma_register_callback
00003550 g       *ABS*	00000000 end
0000215c g     F .exceptions	0000002c alt_instruction_exception_entry
00003ffc g       *ABS*	00000000 __alt_stack_pointer
00002c9c g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
00002e18 g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
00002e98 g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
000022dc g     F .text	00000108 tse_init
00002188 g     F .text	0000004c _start
00003390 g     O .bss	00000004 sgdma_tx_dev
00002c20 g     F .text	0000004c alt_avalon_sgdma_open
00002a20 g     F .text	00000038 alt_sys_init
0000260c g     F .text	0000003c create_udp
00003268 g       *ABS*	00000000 __ram_rwdata_start
00003230 g       *ABS*	00000000 __ram_rodata_start
000031e4 g     F .text	00000030 memcmp
00003550 g       *ABS*	00000000 __alt_stack_base
00003044 g     F .text	0000006c alt_dev_llist_insert
00002bc0 g     F .text	00000018 alt_avalon_sgdma_start
00003390 g       *ABS*	00000000 __bss_start
000026ac g     F .text	00000044 create_icmp
000027c8 g     F .text	00000020 memset
00002734 g     F .text	0000006c main
0000339c g     O .bss	00000004 alt_envp
000032f0 g     O .rwdata	00000008 alt_sgdma_list
000032f8 g     O .rwdata	00000004 alt_errno
00003230 g       *ABS*	00000000 __flash_rodata_start
00002a00 g     F .text	00000020 alt_irq_init
000033a4 g     O .bss	00000004 alt_argc
000024bc g     F .text	000000bc create_arp
00002648 g     F .text	00000064 calculate_checksum
00002020 g       .exceptions	00000000 alt_irq_entry
00002020 g       *ABS*	00000000 __ram_exceptions_start
000021d4 g     F .text	000000a4 button_isr
00002800 g     F .text	00000004 alt_ic_isr_register
000032fc g       *ABS*	00000000 _edata
00003550 g       *ABS*	00000000 _end
00002188 g       *ABS*	00000000 __ram_exceptions_end
0000283c g     F .text	00000038 alt_ic_irq_disable
000032e4 g     O .rwdata	00000001 RTP_PAYLOAD_TYPE
00003410 g     O .bss	00000020 tx_descriptor_end
00002f50 g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
000032d4 g     O .rwdata	00000004 icmp
0000247c g     F .text	00000040 create_eth
00003ffc g       *ABS*	00000000 __alt_data_end
00002020 g     F .exceptions	00000000 alt_exception
00003430 g     O .bss	00000020 tx_descriptor_data
00003394 g     O .bss	00000004 sgdma_rx_dev
0000201c g       .entry	00000000 _exit
00003214 g     F .text	0000001c strlen
00003124 g     F .text	0000000c alt_icache_flush_all
000032e8 g     O .rwdata	00000004 alt_priority_mask
00002804 g     F .text	00000038 alt_ic_irq_enable
00002dd0 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
000028f4 g     F .text	000000e0 alt_load
00002f98 g     F .text	00000084 alt_avalon_sgdma_init



Disassembly of section .entry:

00002000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
    2000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
    2004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
    2008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
    200c:	00bffd16 	blt	zero,r2,2004 <_gp+0xffff6d3c>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    2010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    2014:	08486214 	ori	at,at,8584
    jmp r1
    2018:	0800683a 	jmp	at

0000201c <_exit>:
    201c:	00000000 	call	0 <__alt_mem_system_ram-0x2000>

Disassembly of section .exceptions:

00002020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    2020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    2024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    2028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    202c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    2030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    2034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    2038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    203c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    2040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    2044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    2048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    204c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    2050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    2054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    2058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    205c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    2060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    2064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    2068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    206c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    2070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    2074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    2078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    207c:	10000326 	beq	r2,zero,208c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    2080:	20000226 	beq	r4,zero,208c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    2084:	00020fc0 	call	20fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    2088:	00000706 	br	20a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
    208c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
    2090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
    2094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
    2098:	000215c0 	call	215c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
    209c:	1000021e 	bne	r2,zero,20a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
    20a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    20a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    20a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    20ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    20b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    20b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    20b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    20bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    20c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    20c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    20c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    20cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    20d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    20d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    20d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    20dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    20e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    20e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    20e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    20ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    20f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    20f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    20f8:	ef80083a 	eret

000020fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    20fc:	defffe04 	addi	sp,sp,-8
    2100:	dfc00115 	stw	ra,4(sp)
    2104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    2108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    210c:	04000034 	movhi	r16,0
    2110:	840d1404 	addi	r16,r16,13392

  active = alt_irq_pending ();

  do
  {
    i = 0;
    2114:	0005883a 	mov	r2,zero
    mask = 1;
    2118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    211c:	20ca703a 	and	r5,r4,r3
    2120:	28000b26 	beq	r5,zero,2150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    2124:	100490fa 	slli	r2,r2,3
    2128:	8085883a 	add	r2,r16,r2
    212c:	10c00017 	ldw	r3,0(r2)
    2130:	11000117 	ldw	r4,4(r2)
    2134:	183ee83a 	callr	r3
    2138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    213c:	203ff51e 	bne	r4,zero,2114 <_gp+0xffff6e4c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    2140:	dfc00117 	ldw	ra,4(sp)
    2144:	dc000017 	ldw	r16,0(sp)
    2148:	dec00204 	addi	sp,sp,8
    214c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    2150:	18c7883a 	add	r3,r3,r3
      i++;
    2154:	10800044 	addi	r2,r2,1

    } while (1);
    2158:	003ff006 	br	211c <_gp+0xffff6e54>

0000215c <alt_instruction_exception_entry>:
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
    215c:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
    2160:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
    2164:	d0e03817 	ldw	r3,-32544(gp)
    2168:	18000426 	beq	r3,zero,217c <alt_instruction_exception_entry+0x20>
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
    216c:	10801f0c 	andi	r2,r2,124
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
    2170:	200b883a 	mov	r5,r4
    2174:	1008d0ba 	srli	r4,r2,2
    2178:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
    217c:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
    2180:	0005883a 	mov	r2,zero
    2184:	f800283a 	ret

Disassembly of section .text:

00002188 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
    2188:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
    218c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
    2190:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
    2194:	00bffd16 	blt	zero,r2,218c <_gp+0xffff6ec4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    2198:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    219c:	decfff14 	ori	sp,sp,16380
    movhi gp, %hi(_gp)
    21a0:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    21a4:	d6acb214 	ori	gp,gp,45768
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    21a8:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    21ac:	108ce414 	ori	r2,r2,13200

    movhi r3, %hi(__bss_end)
    21b0:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    21b4:	18cd5414 	ori	r3,r3,13648

    beq r2, r3, 1f
    21b8:	10c00326 	beq	r2,r3,21c8 <_start+0x40>

0:
    stw zero, (r2)
    21bc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    21c0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    21c4:	10fffd36 	bltu	r2,r3,21bc <_gp+0xffff6ef4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    21c8:	00028f40 	call	28f4 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    21cc:	00029d40 	call	29d4 <alt_main>

000021d0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    21d0:	003fff06 	br	21d0 <_gp+0xffff6f08>

000021d4 <button_isr>:



// Handler of timer interrupt
void button_isr(void* context)
{
    21d4:	defffa04 	addi	sp,sp,-24
    21d8:	dc000415 	stw	r16,16(sp)
    21dc:	dfc00515 	stw	ra,20(sp)
    // Clear flag of interrupt

	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ETH_IRQ_PIO_BASE, 0x1);
    21e0:	04000044 	movi	r16,1
    21e4:	00800304 	movi	r2,12
    21e8:	14000035 	stwio	r16,0(r2)


    alt_dcache_flush_all();
    21ec:	00027e80 	call	27e8 <alt_dcache_flush_all>
	alt_avalon_sgdma_construct_mem_to_stream_desc(&tx_descriptor_header, &tx_descriptor_data, (alt_u32 *)HEADER_RAM_BASE, 54, 0, 1, 0, 0);
    21f0:	01400034 	movhi	r5,0
    21f4:	01000034 	movhi	r4,0
    21f8:	01c00d84 	movi	r7,54
    21fc:	01958004 	movi	r6,22016
    2200:	294d0c04 	addi	r5,r5,13360
    2204:	210cec04 	addi	r4,r4,13232
    2208:	d8000315 	stw	zero,12(sp)
    220c:	d8000215 	stw	zero,8(sp)
    2210:	dc000115 	stw	r16,4(sp)
    2214:	d8000015 	stw	zero,0(sp)
    2218:	0002f100 	call	2f10 <alt_avalon_sgdma_construct_mem_to_stream_desc>
	alt_avalon_sgdma_construct_mem_to_stream_desc(&tx_descriptor_data, &tx_descriptor_end, TX_DMA_M_READ_TX_BUFF_RAM_BASE, 1280, 0, 0, 1, 0);
    221c:	01400034 	movhi	r5,0
    2220:	01000034 	movhi	r4,0
    2224:	294d0404 	addi	r5,r5,13328
    2228:	210d0c04 	addi	r4,r4,13360
    222c:	d8000315 	stw	zero,12(sp)
    2230:	dc000215 	stw	r16,8(sp)
    2234:	d8000115 	stw	zero,4(sp)
    2238:	d8000015 	stw	zero,0(sp)
    223c:	01c14004 	movi	r7,1280
    2240:	000d883a 	mov	r6,zero
    2244:	0002f100 	call	2f10 <alt_avalon_sgdma_construct_mem_to_stream_desc>

	alt_avalon_sgdma_do_async_transfer(sgdma_tx_dev, &tx_descriptor_header);
    2248:	d1203217 	ldw	r4,-32568(gp)
    224c:	01400034 	movhi	r5,0
    2250:	294cec04 	addi	r5,r5,13232
    2254:	0002ab40 	call	2ab4 <alt_avalon_sgdma_do_async_transfer>
	while (alt_avalon_sgdma_check_descriptor_status(&tx_descriptor_data) != 0);
    2258:	01000034 	movhi	r4,0
    225c:	210d0c04 	addi	r4,r4,13360
    2260:	0002bf40 	call	2bf4 <alt_avalon_sgdma_check_descriptor_status>
    2264:	103ffc1e 	bne	r2,zero,2258 <_gp+0xffff6f90>

}
    2268:	dfc00517 	ldw	ra,20(sp)
    226c:	dc000417 	ldw	r16,16(sp)
    2270:	dec00604 	addi	sp,sp,24
    2274:	f800283a 	ret

00002278 <sgdma_rx_irq_handler>:
	return(0);
}

// Handler of SGDMA Receive interrupt
void sgdma_rx_irq_handler(void *context)
{
    2278:	defffe04 	addi	sp,sp,-8
    227c:	dfc00115 	stw	ra,4(sp)
	while (alt_avalon_sgdma_check_descriptor_status(&rx_descriptor) != 0);
    2280:	01000034 	movhi	r4,0
    2284:	210cfc04 	addi	r4,r4,13296
    2288:	0002bf40 	call	2bf4 <alt_avalon_sgdma_check_descriptor_status>
    228c:	103ffc1e 	bne	r2,zero,2280 <_gp+0xffff6fb8>

	alt_u8 *frame_pc = (alt_u8 *)(HEADER_RAM_BASE + 100);

	alt_dcache_flush_all();
    2290:	00027e80 	call	27e8 <alt_dcache_flush_all>
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
    2294:	01400034 	movhi	r5,0
    2298:	01000034 	movhi	r4,0
    229c:	000f883a 	mov	r7,zero
    22a0:	01959904 	movi	r6,22116
    22a4:	d8000015 	stw	zero,0(sp)
    22a8:	294cf404 	addi	r5,r5,13264
    22ac:	210cfc04 	addi	r4,r4,13296
    22b0:	0002e980 	call	2e98 <alt_avalon_sgdma_construct_stream_to_mem_desc>
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);
    22b4:	d1203317 	ldw	r4,-32564(gp)
    22b8:	01400034 	movhi	r5,0
    22bc:	294cfc04 	addi	r5,r5,13296
    22c0:	0002ab40 	call	2ab4 <alt_avalon_sgdma_do_async_transfer>

	memset(frame_pc, 0, 100);
    22c4:	01801904 	movi	r6,100
    22c8:	000b883a 	mov	r5,zero
    22cc:	01159904 	movi	r4,22116
}
    22d0:	dfc00117 	ldw	ra,4(sp)
    22d4:	dec00204 	addi	sp,sp,8

	alt_dcache_flush_all();
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);

	memset(frame_pc, 0, 100);
    22d8:	00027c81 	jmpi	27c8 <memset>

000022dc <tse_init>:

// Initialization of Triple-Speed Ethernet
void tse_init(void)
{
	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x00;
    22dc:	d0e00117 	ldw	r3,-32764(gp)

	// Disable read and write transfers and wait
	IOWR(tse, 0x02, 0x00800220);
    22e0:	00802034 	movhi	r2,128
    22e4:	10808804 	addi	r2,r2,544

// Initialization of Triple-Speed Ethernet
void tse_init(void)
{
	// Specify the addresses of the PHY devices to be accessed through MDIO interface
	*(tse + 0x0F) = 0x00;
    22e8:	18000f15 	stw	zero,60(r3)

	// Disable read and write transfers and wait
	IOWR(tse, 0x02, 0x00800220);
    22ec:	18800235 	stwio	r2,8(r3)
	while ( IORD(tse, 0x02) !=  0x00800220 );
    22f0:	d0e00117 	ldw	r3,-32764(gp)
    22f4:	19000237 	ldwio	r4,8(r3)
    22f8:	20bffd1e 	bne	r4,r2,22f0 <_gp+0xffff7028>

	// MAC FIFO Configuration
	IOWR(tse, 0x09, TSE_RECEIVE_FIFO_DEPTH-16);
    22fc:	01001c04 	movi	r4,112
    2300:	19000935 	stwio	r4,36(r3)
	IOWR(tse, 0x0E, 3);
    2304:	d0e00117 	ldw	r3,-32764(gp)
    2308:	014000c4 	movi	r5,3
    230c:	19400e35 	stwio	r5,56(r3)
	IOWR(tse, 0x0D, 8);
    2310:	d1600117 	ldw	r5,-32764(gp)
    2314:	00c00204 	movi	r3,8
    2318:	28c00d35 	stwio	r3,52(r5)
	IOWR(tse, 0x07, TSE_RECEIVE_FIFO_DEPTH-16);
    231c:	d1600117 	ldw	r5,-32764(gp)
    2320:	29000735 	stwio	r4,28(r5)
	IOWR(tse, 0x0C, 8);
    2324:	d1200117 	ldw	r4,-32764(gp)
    2328:	20c00c35 	stwio	r3,48(r4)
	IOWR(tse, 0x0B, 8);
    232c:	d1200117 	ldw	r4,-32764(gp)
    2330:	20c00b35 	stwio	r3,44(r4)
	IOWR(tse, 0x0A, 0);
    2334:	d0e00117 	ldw	r3,-32764(gp)
    2338:	18000a35 	stwio	zero,40(r3)
	IOWR(tse, 0x08, 0);
    233c:	d0e00117 	ldw	r3,-32764(gp)
    2340:	18000835 	stwio	zero,32(r3)

	// Initialize the MAC address
	IOWR(tse, 0x03, 0xEFBEADDE);
    2344:	d0e00117 	ldw	r3,-32764(gp)
    2348:	013beff4 	movhi	r4,61375
    234c:	212b7784 	addi	r4,r4,-21026
    2350:	19000335 	stwio	r4,12(r3)
	IOWR(tse, 0x04, 0x0000FECA);
    2354:	d0e00117 	ldw	r3,-32764(gp)
    2358:	013fb294 	movui	r4,65226
    235c:	19000435 	stwio	r4,16(r3)

	// MAC function configuration
	IOWR(tse, 0x05, 1280 + 54);
    2360:	d0e00117 	ldw	r3,-32764(gp)
    2364:	01014d84 	movi	r4,1334
    2368:	19000535 	stwio	r4,20(r3)
	IOWR(tse, 0x17, 12);
    236c:	d0e00117 	ldw	r3,-32764(gp)
    2370:	01000304 	movi	r4,12
    2374:	19001735 	stwio	r4,92(r3)
	IOWR(tse, 0x06, 0xFFFF);
    2378:	d0e00117 	ldw	r3,-32764(gp)
    237c:	013fffd4 	movui	r4,65535
    2380:	19000635 	stwio	r4,24(r3)
	IOWR(tse, 0x02, 0x00800220);
    2384:	d0e00117 	ldw	r3,-32764(gp)
    2388:	18800235 	stwio	r2,8(r3)
	while (IORD(tse, 0x02 ) != 0x00800220);
    238c:	d0e00117 	ldw	r3,-32764(gp)
    2390:	18c00204 	addi	r3,r3,8
    2394:	19000037 	ldwio	r4,0(r3)
    2398:	20bffc1e 	bne	r4,r2,238c <_gp+0xffff70c4>

	// Software reset the PHY chip and wait
	IOWR(tse, 0x02, (IORD(tse, 0x02) | 0x2000));
    239c:	18800037 	ldwio	r2,0(r3)
    23a0:	10880014 	ori	r2,r2,8192
    23a4:	18800035 	stwio	r2,0(r3)
	while ((IORD(tse, 0x02) & 0x2000) != 0);
    23a8:	d0a00117 	ldw	r2,-32764(gp)
    23ac:	10c00237 	ldwio	r3,8(r2)
    23b0:	18c8000c 	andi	r3,r3,8192
    23b4:	183ffc1e 	bne	r3,zero,23a8 <_gp+0xffff70e0>
	*(tse + 0x02 ) = *(tse + 0x02 ) | 0x0080023B;
    23b8:	11000217 	ldw	r4,8(r2)
    23bc:	00c02034 	movhi	r3,128
    23c0:	18c08ec4 	addi	r3,r3,571
    23c4:	20c8b03a 	or	r4,r4,r3
    23c8:	11000215 	stw	r4,8(r2)
	while ( *(tse + 0x02 ) != ( *(tse + 0x02) | 0x0080023B ) );
    23cc:	11400217 	ldw	r5,8(r2)
    23d0:	11000217 	ldw	r4,8(r2)
    23d4:	20c8b03a 	or	r4,r4,r3
    23d8:	293ffc1e 	bne	r5,r4,23cc <_gp+0xffff7104>

	IOWR(tse, 0x3a, 0x0000);
    23dc:	10003a35 	stwio	zero,232(r2)
    23e0:	f800283a 	ret

000023e4 <open_sgdma>:

// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
    23e4:	01000034 	movhi	r4,0

}

// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
    23e8:	defffe04 	addi	sp,sp,-8
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
    23ec:	210c8c04 	addi	r4,r4,12848

}

// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
    23f0:	dfc00115 	stw	ra,4(sp)
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
    23f4:	0002c200 	call	2c20 <alt_avalon_sgdma_open>
    23f8:	d0a03215 	stw	r2,-32568(gp)
	if (sgdma_tx_dev == NULL) return(1);
    23fc:	10001926 	beq	r2,zero,2464 <open_sgdma+0x80>

	// Transmit device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/rx_dma");
    2400:	01000034 	movhi	r4,0
    2404:	210c8f04 	addi	r4,r4,12860
    2408:	0002c200 	call	2c20 <alt_avalon_sgdma_open>
    240c:	d0a03315 	stw	r2,-32564(gp)
	if (sgdma_rx_dev == NULL) return(2);
    2410:	10001626 	beq	r2,zero,246c <open_sgdma+0x88>

	// Register receive interrupt handler and allocate memory area
	alt_avalon_sgdma_register_callback(sgdma_rx_dev, (alt_avalon_sgdma_callback)sgdma_rx_irq_handler, 0x00000014, NULL);
    2414:	01400034 	movhi	r5,0
    2418:	1009883a 	mov	r4,r2
    241c:	000f883a 	mov	r7,zero
    2420:	01800504 	movi	r6,20
    2424:	29489e04 	addi	r5,r5,8824
    2428:	0002bb00 	call	2bb0 <alt_avalon_sgdma_register_callback>
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
    242c:	01400034 	movhi	r5,0
    2430:	01000034 	movhi	r4,0
    2434:	000f883a 	mov	r7,zero
    2438:	01959904 	movi	r6,22116
    243c:	294cf404 	addi	r5,r5,13264
    2440:	210cfc04 	addi	r4,r4,13296
    2444:	d8000015 	stw	zero,0(sp)
    2448:	0002e980 	call	2e98 <alt_avalon_sgdma_construct_stream_to_mem_desc>
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);
    244c:	d1203317 	ldw	r4,-32564(gp)
    2450:	01400034 	movhi	r5,0
    2454:	294cfc04 	addi	r5,r5,13296
    2458:	0002ab40 	call	2ab4 <alt_avalon_sgdma_do_async_transfer>

	return(0);
    245c:	0005883a 	mov	r2,zero
    2460:	00000306 	br	2470 <open_sgdma+0x8c>
// Open the SGDMA transmit/receive device
alt_u8 open_sgdma(void)
{
	// Transmit device
	sgdma_tx_dev = alt_avalon_sgdma_open ("/dev/tx_dma");
	if (sgdma_tx_dev == NULL) return(1);
    2464:	00800044 	movi	r2,1
    2468:	00000106 	br	2470 <open_sgdma+0x8c>

	// Transmit device
	sgdma_rx_dev = alt_avalon_sgdma_open ("/dev/rx_dma");
	if (sgdma_rx_dev == NULL) return(2);
    246c:	00800084 	movi	r2,2
	alt_avalon_sgdma_register_callback(sgdma_rx_dev, (alt_avalon_sgdma_callback)sgdma_rx_irq_handler, 0x00000014, NULL);
	alt_avalon_sgdma_construct_stream_to_mem_desc(&rx_descriptor, &rx_descriptor_end, (alt_u32 *)(HEADER_RAM_BASE + 100), 0, 0);
	alt_avalon_sgdma_do_async_transfer(sgdma_rx_dev, &rx_descriptor);

	return(0);
}
    2470:	dfc00117 	ldw	ra,4(sp)
    2474:	dec00204 	addi	sp,sp,8
    2478:	f800283a 	ret

0000247c <create_eth>:
	memset(frame_pc, 0, 100);
}

// Create ETH header (struct eth, type - encapsulation protocol)
void create_eth(struct eth_hdr *eth)
{
    247c:	defffe04 	addi	sp,sp,-8
    2480:	dc000015 	stw	r16,0(sp)
	memcpy(eth->mac_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", 6);
    2484:	01400034 	movhi	r5,0
    2488:	04000184 	movi	r16,6
    248c:	800d883a 	mov	r6,r16
    2490:	294c9204 	addi	r5,r5,12872
	memset(frame_pc, 0, 100);
}

// Create ETH header (struct eth, type - encapsulation protocol)
void create_eth(struct eth_hdr *eth)
{
    2494:	dfc00115 	stw	ra,4(sp)
	memcpy(eth->mac_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", 6);
    2498:	00027a00 	call	27a0 <memcpy>
	memcpy(eth->mac_src, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    249c:	01400034 	movhi	r5,0
    24a0:	800d883a 	mov	r6,r16
    24a4:	294c9404 	addi	r5,r5,12880
    24a8:	1409883a 	add	r4,r2,r16
}
    24ac:	dfc00117 	ldw	ra,4(sp)
    24b0:	dc000017 	ldw	r16,0(sp)
    24b4:	dec00204 	addi	sp,sp,8

// Create ETH header (struct eth, type - encapsulation protocol)
void create_eth(struct eth_hdr *eth)
{
	memcpy(eth->mac_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", 6);
	memcpy(eth->mac_src, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    24b8:	00027a01 	jmpi	27a0 <memcpy>

000024bc <create_arp>:
}

// Create ARP packet (struct arp, operation - request/reply)
void create_arp(struct arp_packet *arp, alt_u16 operation)
{
    24bc:	defffc04 	addi	sp,sp,-16
    24c0:	dfc00315 	stw	ra,12(sp)
    24c4:	dc800215 	stw	r18,8(sp)
    24c8:	dc400115 	stw	r17,4(sp)
    24cc:	dc000015 	stw	r16,0(sp)
	arp->eth_type = __builtin_bswap16(0x0806);
    24d0:	00818204 	movi	r2,1544
    24d4:	2080000d 	sth	r2,0(r4)
	arp->hw_type = __builtin_bswap16(0x0001);
    24d8:	00804004 	movi	r2,256
    24dc:	2080008d 	sth	r2,2(r4)
	arp->proto_type = __builtin_bswap16(0x0800);
    24e0:	00800204 	movi	r2,8
    24e4:	2080010d 	sth	r2,4(r4)
	arp->hw_len = 6;
    24e8:	00800184 	movi	r2,6
    24ec:	20800185 	stb	r2,6(r4)
	arp->proto_len = 4;

	// Operation (ARP-request = 1, ARP-reply = 2)
	arp->operation = __builtin_bswap16(operation);
    24f0:	297fffcc 	andi	r5,r5,65535
{
	arp->eth_type = __builtin_bswap16(0x0806);
	arp->hw_type = __builtin_bswap16(0x0001);
	arp->proto_type = __builtin_bswap16(0x0800);
	arp->hw_len = 6;
	arp->proto_len = 4;
    24f4:	00800104 	movi	r2,4
    24f8:	208001c5 	stb	r2,7(r4)

	// Operation (ARP-request = 1, ARP-reply = 2)
	arp->operation = __builtin_bswap16(operation);
    24fc:	2804923a 	slli	r2,r5,8
    2500:	280ad23a 	srli	r5,r5,8

	memcpy(arp->sender_mac, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    2504:	04800184 	movi	r18,6
	memcpy(eth->mac_src, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
}

// Create ARP packet (struct arp, operation - request/reply)
void create_arp(struct arp_packet *arp, alt_u16 operation)
{
    2508:	2021883a 	mov	r16,r4
	arp->proto_type = __builtin_bswap16(0x0800);
	arp->hw_len = 6;
	arp->proto_len = 4;

	// Operation (ARP-request = 1, ARP-reply = 2)
	arp->operation = __builtin_bswap16(operation);
    250c:	114ab03a 	or	r5,r2,r5
    2510:	2140020d 	sth	r5,8(r4)

	memcpy(arp->sender_mac, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
    2514:	01400034 	movhi	r5,0
    2518:	900d883a 	mov	r6,r18
    251c:	294c9404 	addi	r5,r5,12880
    2520:	21000284 	addi	r4,r4,10
    2524:	00027a00 	call	27a0 <memcpy>
	memcpy(arp->sender_ip, "\xC0\xA8\x01\x02", 4);
    2528:	04400104 	movi	r17,4
    252c:	01400034 	movhi	r5,0
    2530:	880d883a 	mov	r6,r17
    2534:	81000404 	addi	r4,r16,16
    2538:	294c9604 	addi	r5,r5,12888
    253c:	00027a00 	call	27a0 <memcpy>
	memset(arp->target_mac, 0, 6);
    2540:	900d883a 	mov	r6,r18
    2544:	81000504 	addi	r4,r16,20
    2548:	000b883a 	mov	r5,zero
    254c:	00027c80 	call	27c8 <memset>
	memcpy(arp->target_ip, "\xC0\xA8\x01\x05", 4);
    2550:	01400034 	movhi	r5,0
    2554:	880d883a 	mov	r6,r17
    2558:	294c9804 	addi	r5,r5,12896
    255c:	81000684 	addi	r4,r16,26
}
    2560:	dfc00317 	ldw	ra,12(sp)
    2564:	dc800217 	ldw	r18,8(sp)
    2568:	dc400117 	ldw	r17,4(sp)
    256c:	dc000017 	ldw	r16,0(sp)
    2570:	dec00404 	addi	sp,sp,16
	arp->operation = __builtin_bswap16(operation);

	memcpy(arp->sender_mac, "\xDE\xAD\xBE\xEF\xCA\xFE", 6);
	memcpy(arp->sender_ip, "\xC0\xA8\x01\x02", 4);
	memset(arp->target_mac, 0, 6);
	memcpy(arp->target_ip, "\xC0\xA8\x01\x05", 4);
    2574:	00027a01 	jmpi	27a0 <memcpy>

00002578 <create_ip>:
}

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
    2578:	defffd04 	addi	sp,sp,-12
    257c:	dc400115 	stw	r17,4(sp)
    2580:	dc000015 	stw	r16,0(sp)
    2584:	dfc00215 	stw	ra,8(sp)
	ip->eth_type = __builtin_bswap16(0x0800);
    2588:	00800204 	movi	r2,8
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
    258c:	31800604 	addi	r6,r6,24
}

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
    2590:	2080000d 	sth	r2,0(r4)
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
    2594:	31bfffcc 	andi	r6,r6,65535

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
    2598:	00801144 	movi	r2,69
    259c:	20800085 	stb	r2,2(r4)
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
    25a0:	3004923a 	slli	r2,r6,8
    25a4:	300cd23a 	srli	r6,r6,8
	ip->id = 0;
	ip->flags_offset = 0;
	ip->ttl = 0x40;
	ip->protocol = protocol;
    25a8:	214002c5 	stb	r5,11(r4)
	ip->checksum = 0;
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
    25ac:	04400104 	movi	r17,4
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
    25b0:	118cb03a 	or	r6,r2,r6
	ip->id = 0;
	ip->flags_offset = 0;
	ip->ttl = 0x40;
	ip->protocol = protocol;
	ip->checksum = 0;
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
    25b4:	01400034 	movhi	r5,0
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
	ip->id = 0;
	ip->flags_offset = 0;
	ip->ttl = 0x40;
    25b8:	00801004 	movi	r2,64
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
    25bc:	2180010d 	sth	r6,4(r4)
	memcpy(arp->target_ip, "\xC0\xA8\x01\x05", 4);
}

// Create IP header (struct ip, protocol - encapsulation protocol, data_len - length of data after IP header)
void create_ip(struct ip_hdr *ip, alt_u8 protocol, alt_u32 data_len)
{
    25c0:	2021883a 	mov	r16,r4
	ip->eth_type = __builtin_bswap16(0x0800);
	ip->ver_ihl = 0x45;
	ip->tos = 0x00;
    25c4:	200000c5 	stb	zero,3(r4)
	ip->len = __builtin_bswap16(sizeof(struct ip_hdr) + 2 + data_len);
	ip->id = 0;
    25c8:	2000018d 	sth	zero,6(r4)
	ip->flags_offset = 0;
    25cc:	2000020d 	sth	zero,8(r4)
	ip->ttl = 0x40;
    25d0:	20800285 	stb	r2,10(r4)
	ip->protocol = protocol;
	ip->checksum = 0;
    25d4:	2000030d 	sth	zero,12(r4)
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
    25d8:	880d883a 	mov	r6,r17
    25dc:	294c9604 	addi	r5,r5,12888
    25e0:	21000384 	addi	r4,r4,14
    25e4:	00027a00 	call	27a0 <memcpy>
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
    25e8:	01400034 	movhi	r5,0
    25ec:	880d883a 	mov	r6,r17
    25f0:	294c9804 	addi	r5,r5,12896
    25f4:	81000484 	addi	r4,r16,18
}
    25f8:	dfc00217 	ldw	ra,8(sp)
    25fc:	dc400117 	ldw	r17,4(sp)
    2600:	dc000017 	ldw	r16,0(sp)
    2604:	dec00304 	addi	sp,sp,12
	ip->flags_offset = 0;
	ip->ttl = 0x40;
	ip->protocol = protocol;
	ip->checksum = 0;
	memcpy(ip->ip_src, "\xC0\xA8\x01\x02", 4);
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
    2608:	00027a01 	jmpi	27a0 <memcpy>

0000260c <create_udp>:
}

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
    260c:	00a304c4 	movi	r2,-29677
	udp->port_dest = __builtin_bswap16(dest_port);
    2610:	297fffcc 	andi	r5,r5,65535
}

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
    2614:	2080000d 	sth	r2,0(r4)
	udp->port_dest = __builtin_bswap16(dest_port);
    2618:	2804923a 	slli	r2,r5,8
    261c:	280ad23a 	srli	r5,r5,8
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    2620:	31800204 	addi	r6,r6,8
    2624:	31bfffcc 	andi	r6,r6,65535

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
	udp->port_dest = __builtin_bswap16(dest_port);
    2628:	114ab03a 	or	r5,r2,r5
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    262c:	3004923a 	slli	r2,r6,8
    2630:	300cd23a 	srli	r6,r6,8

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
	udp->port_dest = __builtin_bswap16(dest_port);
    2634:	2140008d 	sth	r5,2(r4)
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
	udp->checksum = 0;
    2638:	2000018d 	sth	zero,6(r4)
// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
	udp->port_dest = __builtin_bswap16(dest_port);
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    263c:	118cb03a 	or	r6,r2,r6
    2640:	2180010d 	sth	r6,4(r4)
	udp->checksum = 0;
    2644:	f800283a 	ret

00002648 <calculate_checksum>:
}

// Calculate checksum for IP/ICMP/UDP/TCP
alt_u16 calculate_checksum(alt_u8* data, alt_u32 length)
{
    2648:	200d883a 	mov	r6,r4
    alt_u16* buffer = (alt_u16 *)data;
    alt_u16 temp = 0;

    while (length > 1)
    264c:	2805883a 	mov	r2,r5

// Calculate checksum for IP/ICMP/UDP/TCP
alt_u16 calculate_checksum(alt_u8* data, alt_u32 length)
{
    alt_u16* buffer = (alt_u16 *)data;
    alt_u16 temp = 0;
    2650:	0007883a 	mov	r3,zero

    while (length > 1)
    2654:	01c00044 	movi	r7,1
    2658:	3880052e 	bgeu	r7,r2,2670 <calculate_checksum+0x28>
    {
        temp += *buffer++;
    265c:	3200000b 	ldhu	r8,0(r6)
        length -= 2;
    2660:	10bfff84 	addi	r2,r2,-2
    2664:	31800084 	addi	r6,r6,2
    alt_u16* buffer = (alt_u16 *)data;
    alt_u16 temp = 0;

    while (length > 1)
    {
        temp += *buffer++;
    2668:	40c7883a 	add	r3,r8,r3
    266c:	003ffa06 	br	2658 <_gp+0xffff7390>
    2670:	2804d07a 	srli	r2,r5,1
        length -= 2;
    }

    if (length == 1) temp += *(alt_u8 *)buffer << 8;
    2674:	288bc83a 	sub	r5,r5,r2
    2678:	108d883a 	add	r6,r2,r2
    267c:	288bc83a 	sub	r5,r5,r2
    2680:	00800044 	movi	r2,1
    2684:	2189883a 	add	r4,r4,r6
    2688:	2880031e 	bne	r5,r2,2698 <calculate_checksum+0x50>
    268c:	20800003 	ldbu	r2,0(r4)
    2690:	1004923a 	slli	r2,r2,8
    2694:	10c7883a 	add	r3,r2,r3
    while (temp >> 16) temp = (temp & 0xFFFF) + (temp >> 16);
    return ~((temp >> 8) | (temp << 8));
    2698:	1804923a 	slli	r2,r3,8
    269c:	18ffffcc 	andi	r3,r3,65535
    26a0:	1806d23a 	srli	r3,r3,8
}
    26a4:	10c4303a 	nor	r2,r2,r3
    26a8:	f800283a 	ret

000026ac <create_icmp>:
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
}

// Create ICMP packet
void create_icmp(struct icmp_packet *icmp, alt_u16 id, alt_u16 seq, alt_u8 *data)
{
    26ac:	defffe04 	addi	sp,sp,-8
	icmp->type = 0;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->id = id;
    26b0:	2140010d 	sth	r5,4(r4)
}

// Create ICMP packet
void create_icmp(struct icmp_packet *icmp, alt_u16 id, alt_u16 seq, alt_u8 *data)
{
	icmp->type = 0;
    26b4:	20000005 	stb	zero,0(r4)
	icmp->code = 0;
    26b8:	20000045 	stb	zero,1(r4)
	icmp->checksum = 0;
    26bc:	2000008d 	sth	zero,2(r4)
	icmp->id = id;
	icmp->sequence = seq;
    26c0:	2180018d 	sth	r6,6(r4)
	icmp->data = data;
    26c4:	21c00215 	stw	r7,8(r4)
	icmp->checksum = calculate_checksum((alt_u8 *)icmp, sizeof(icmp));
    26c8:	01400104 	movi	r5,4
	memcpy(ip->ip_dest, "\xC0\xA8\x01\x05", 4);
}

// Create ICMP packet
void create_icmp(struct icmp_packet *icmp, alt_u16 id, alt_u16 seq, alt_u8 *data)
{
    26cc:	dc000015 	stw	r16,0(sp)
    26d0:	dfc00115 	stw	ra,4(sp)
    26d4:	2021883a 	mov	r16,r4
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->id = id;
	icmp->sequence = seq;
	icmp->data = data;
	icmp->checksum = calculate_checksum((alt_u8 *)icmp, sizeof(icmp));
    26d8:	00026480 	call	2648 <calculate_checksum>
    26dc:	8080008d 	sth	r2,2(r16)
}
    26e0:	dfc00117 	ldw	ra,4(sp)
    26e4:	dc000017 	ldw	r16,0(sp)
    26e8:	dec00204 	addi	sp,sp,8
    26ec:	f800283a 	ret

000026f0 <pio_init>:
    return ~((temp >> 8) | (temp << 8));
}


void pio_init(void)
{
    26f0:	defffe04 	addi	sp,sp,-8
    26f4:	dfc00115 	stw	ra,4(sp)
	// Init PIO interrupt, 0b1 for 3 btn
	IOWR_ALTERA_AVALON_PIO_IRQ_MASK(ETH_IRQ_PIO_BASE, 0x1);
    26f8:	00800044 	movi	r2,1
    26fc:	00c00204 	movi	r3,8
    2700:	18800035 	stwio	r2,0(r3)
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ETH_IRQ_PIO_BASE, 0x1);
    2704:	00c00304 	movi	r3,12
    2708:	18800035 	stwio	r2,0(r3)

	// Register interrupt from PIO
	alt_ic_isr_register(ETH_IRQ_PIO_IRQ_INTERRUPT_CONTROLLER_ID, ETH_IRQ_PIO_IRQ, button_isr, 0, 0);
    270c:	01800034 	movhi	r6,0
    2710:	d8000015 	stw	zero,0(sp)
    2714:	000f883a 	mov	r7,zero
    2718:	31887504 	addi	r6,r6,8660
    271c:	01400104 	movi	r5,4
    2720:	0009883a 	mov	r4,zero
    2724:	00028000 	call	2800 <alt_ic_isr_register>
}
    2728:	dfc00117 	ldw	ra,4(sp)
    272c:	dec00204 	addi	sp,sp,8
    2730:	f800283a 	ret

00002734 <main>:
alt_u8 fl_proto = 1;

/****************** Main block ******************/
int main(void)
{
	create_eth(eth);
    2734:	d1200617 	ldw	r4,-32744(gp)
// Flag to set MAC-address of PC
alt_u8 fl_proto = 1;

/****************** Main block ******************/
int main(void)
{
    2738:	deffff04 	addi	sp,sp,-4
    273c:	dfc00015 	stw	ra,0(sp)
	create_eth(eth);
    2740:	000247c0 	call	247c <create_eth>
	create_ip(ip, 17, 1280 + sizeof(udp));
    2744:	d1200417 	ldw	r4,-32752(gp)
    2748:	01814104 	movi	r6,1284
    274c:	01400444 	movi	r5,17
    2750:	00025780 	call	2578 <create_ip>
	create_udp(udp, 5004, 1280);
    2754:	d0a00217 	ldw	r2,-32760(gp)
}

// Create UDP header
void create_udp(struct udp_hdr *udp, alt_u16 dest_port, alt_u32 data_len)
{
	udp->port_src = __builtin_bswap16(5004);
    2758:	00e304c4 	movi	r3,-29677
    275c:	10c0000d 	sth	r3,0(r2)
	udp->port_dest = __builtin_bswap16(dest_port);
    2760:	10c0008d 	sth	r3,2(r2)
	udp->len = __builtin_bswap16(sizeof(struct udp_hdr) + data_len);
    2764:	00c20144 	movi	r3,2053
    2768:	10c0010d 	sth	r3,4(r2)
	udp->checksum = 0;
    276c:	1000018d 	sth	zero,6(r2)
{
	create_eth(eth);
	create_ip(ip, 17, 1280 + sizeof(udp));
	create_udp(udp, 5004, 1280);

	tse_init();
    2770:	00022dc0 	call	22dc <tse_init>

	alt_u8 sdgma_status = open_sgdma();
    2774:	00023e40 	call	23e4 <open_sgdma>
	if (sdgma_status == 1 || sdgma_status == 2) return(0);
    2778:	10bfffc4 	addi	r2,r2,-1
    277c:	10803fcc 	andi	r2,r2,255
    2780:	00c00044 	movi	r3,1
    2784:	1880022e 	bgeu	r3,r2,2790 <main+0x5c>

	pio_init();
    2788:	00026f00 	call	26f0 <pio_init>
    278c:	003fff06 	br	278c <_gp+0xffff74c4>

	while (1);

	return 0;
}
    2790:	0005883a 	mov	r2,zero
    2794:	dfc00017 	ldw	ra,0(sp)
    2798:	dec00104 	addi	sp,sp,4
    279c:	f800283a 	ret

000027a0 <memcpy>:
    27a0:	2005883a 	mov	r2,r4
    27a4:	2007883a 	mov	r3,r4
    27a8:	218d883a 	add	r6,r4,r6
    27ac:	19800526 	beq	r3,r6,27c4 <memcpy+0x24>
    27b0:	29000003 	ldbu	r4,0(r5)
    27b4:	18c00044 	addi	r3,r3,1
    27b8:	29400044 	addi	r5,r5,1
    27bc:	193fffc5 	stb	r4,-1(r3)
    27c0:	003ffa06 	br	27ac <_gp+0xffff74e4>
    27c4:	f800283a 	ret

000027c8 <memset>:
    27c8:	2005883a 	mov	r2,r4
    27cc:	2007883a 	mov	r3,r4
    27d0:	218d883a 	add	r6,r4,r6
    27d4:	19800326 	beq	r3,r6,27e4 <memset+0x1c>
    27d8:	19400005 	stb	r5,0(r3)
    27dc:	18c00044 	addi	r3,r3,1
    27e0:	003ffc06 	br	27d4 <_gp+0xffff750c>
    27e4:	f800283a 	ret

000027e8 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
    27e8:	0005883a 	mov	r2,zero
    27ec:	00c20004 	movi	r3,2048
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
    27f0:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
    27f4:	10800804 	addi	r2,r2,32
    27f8:	10fffd1e 	bne	r2,r3,27f0 <_gp+0xffff7528>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
    27fc:	f800283a 	ret

00002800 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
    2800:	000288c1 	jmpi	288c <alt_iic_isr_register>

00002804 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2804:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2808:	00bfff84 	movi	r2,-2
    280c:	2084703a 	and	r2,r4,r2
    2810:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    2814:	00c00044 	movi	r3,1
    2818:	d0a03417 	ldw	r2,-32560(gp)
    281c:	194a983a 	sll	r5,r3,r5
    2820:	288ab03a 	or	r5,r5,r2
    2824:	d1603415 	stw	r5,-32560(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    2828:	d0a03417 	ldw	r2,-32560(gp)
    282c:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2830:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
    2834:	0005883a 	mov	r2,zero
    2838:	f800283a 	ret

0000283c <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    283c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2840:	00bfff84 	movi	r2,-2
    2844:	2084703a 	and	r2,r4,r2
    2848:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    284c:	00ffff84 	movi	r3,-2
    2850:	d0a03417 	ldw	r2,-32560(gp)
    2854:	194a183a 	rol	r5,r3,r5
    2858:	288a703a 	and	r5,r5,r2
    285c:	d1603415 	stw	r5,-32560(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    2860:	d0a03417 	ldw	r2,-32560(gp)
    2864:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2868:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
    286c:	0005883a 	mov	r2,zero
    2870:	f800283a 	ret

00002874 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
    2874:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
    2878:	00800044 	movi	r2,1
    287c:	1144983a 	sll	r2,r2,r5
    2880:	10c4703a 	and	r2,r2,r3
}
    2884:	1004c03a 	cmpne	r2,r2,zero
    2888:	f800283a 	ret

0000288c <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
    288c:	00c007c4 	movi	r3,31
    2890:	19401616 	blt	r3,r5,28ec <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    2894:	defffe04 	addi	sp,sp,-8
    2898:	dfc00115 	stw	ra,4(sp)
    289c:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    28a0:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    28a4:	00ffff84 	movi	r3,-2
    28a8:	80c6703a 	and	r3,r16,r3
    28ac:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    28b0:	280490fa 	slli	r2,r5,3
    28b4:	00c00034 	movhi	r3,0
    28b8:	18cd1404 	addi	r3,r3,13392
    28bc:	1885883a 	add	r2,r3,r2
    28c0:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
    28c4:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    28c8:	30000226 	beq	r6,zero,28d4 <alt_iic_isr_register+0x48>
    28cc:	00028040 	call	2804 <alt_ic_irq_enable>
    28d0:	00000106 	br	28d8 <alt_iic_isr_register+0x4c>
    28d4:	000283c0 	call	283c <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    28d8:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
    28dc:	dfc00117 	ldw	ra,4(sp)
    28e0:	dc000017 	ldw	r16,0(sp)
    28e4:	dec00204 	addi	sp,sp,8
    28e8:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
    28ec:	00bffa84 	movi	r2,-22
    28f0:	f800283a 	ret

000028f4 <alt_load>:
    28f4:	deffff04 	addi	sp,sp,-4
    28f8:	01000034 	movhi	r4,0
    28fc:	01400034 	movhi	r5,0
    2900:	dfc00015 	stw	ra,0(sp)
    2904:	210c9a04 	addi	r4,r4,12904
    2908:	294cbf04 	addi	r5,r5,13052
    290c:	2140061e 	bne	r4,r5,2928 <alt_load+0x34>
    2910:	01000034 	movhi	r4,0
    2914:	01400034 	movhi	r5,0
    2918:	21080804 	addi	r4,r4,8224
    291c:	29480804 	addi	r5,r5,8224
    2920:	2140121e 	bne	r4,r5,296c <alt_load+0x78>
    2924:	00000b06 	br	2954 <alt_load+0x60>
    2928:	00c00034 	movhi	r3,0
    292c:	18ccbf04 	addi	r3,r3,13052
    2930:	1907c83a 	sub	r3,r3,r4
    2934:	0005883a 	mov	r2,zero
    2938:	10fff526 	beq	r2,r3,2910 <_gp+0xffff7648>
    293c:	114f883a 	add	r7,r2,r5
    2940:	39c00017 	ldw	r7,0(r7)
    2944:	110d883a 	add	r6,r2,r4
    2948:	10800104 	addi	r2,r2,4
    294c:	31c00015 	stw	r7,0(r6)
    2950:	003ff906 	br	2938 <_gp+0xffff7670>
    2954:	01000034 	movhi	r4,0
    2958:	01400034 	movhi	r5,0
    295c:	210c8c04 	addi	r4,r4,12848
    2960:	294c8c04 	addi	r5,r5,12848
    2964:	2140101e 	bne	r4,r5,29a8 <alt_load+0xb4>
    2968:	00000b06 	br	2998 <alt_load+0xa4>
    296c:	00c00034 	movhi	r3,0
    2970:	18c86204 	addi	r3,r3,8584
    2974:	1907c83a 	sub	r3,r3,r4
    2978:	0005883a 	mov	r2,zero
    297c:	10fff526 	beq	r2,r3,2954 <_gp+0xffff768c>
    2980:	114f883a 	add	r7,r2,r5
    2984:	39c00017 	ldw	r7,0(r7)
    2988:	110d883a 	add	r6,r2,r4
    298c:	10800104 	addi	r2,r2,4
    2990:	31c00015 	stw	r7,0(r6)
    2994:	003ff906 	br	297c <_gp+0xffff76b4>
    2998:	00027e80 	call	27e8 <alt_dcache_flush_all>
    299c:	dfc00017 	ldw	ra,0(sp)
    29a0:	dec00104 	addi	sp,sp,4
    29a4:	00031241 	jmpi	3124 <alt_icache_flush_all>
    29a8:	00c00034 	movhi	r3,0
    29ac:	18cc9a04 	addi	r3,r3,12904
    29b0:	1907c83a 	sub	r3,r3,r4
    29b4:	0005883a 	mov	r2,zero
    29b8:	18bff726 	beq	r3,r2,2998 <_gp+0xffff76d0>
    29bc:	114f883a 	add	r7,r2,r5
    29c0:	39c00017 	ldw	r7,0(r7)
    29c4:	110d883a 	add	r6,r2,r4
    29c8:	10800104 	addi	r2,r2,4
    29cc:	31c00015 	stw	r7,0(r6)
    29d0:	003ff906 	br	29b8 <_gp+0xffff76f0>

000029d4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    29d4:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    29d8:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    29dc:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    29e0:	0002a000 	call	2a00 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    29e4:	0002a200 	call	2a20 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    29e8:	d1a03517 	ldw	r6,-32556(gp)
    29ec:	d1603617 	ldw	r5,-32552(gp)
    29f0:	d1203717 	ldw	r4,-32548(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    29f4:	dfc00017 	ldw	ra,0(sp)
    29f8:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    29fc:	00027341 	jmpi	2734 <main>

00002a00 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    2a00:	deffff04 	addi	sp,sp,-4
    2a04:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
    2a08:	00031a40 	call	31a4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    2a0c:	00800044 	movi	r2,1
    2a10:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    2a14:	dfc00017 	ldw	ra,0(sp)
    2a18:	dec00104 	addi	sp,sp,4
    2a1c:	f800283a 	ret

00002a20 <alt_sys_init>:

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    2a20:	01000034 	movhi	r4,0
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    2a24:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    2a28:	000d883a 	mov	r6,zero
    2a2c:	000b883a 	mov	r5,zero
    2a30:	210ca604 	addi	r4,r4,12952
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    2a34:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    2a38:	0002f980 	call	2f98 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( TX_DMA, tx_dma);
    2a3c:	01000034 	movhi	r4,0
    2a40:	01800044 	movi	r6,1
    2a44:	000b883a 	mov	r5,zero
    2a48:	210c9a04 	addi	r4,r4,12904
    ALTERA_ETH_TSE_INIT ( TSE, tse);
}
    2a4c:	dfc00017 	ldw	ra,0(sp)
    2a50:	dec00104 	addi	sp,sp,4
void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
    ALTERA_AVALON_SGDMA_INIT ( RX_DMA, rx_dma);
    ALTERA_AVALON_SGDMA_INIT ( TX_DMA, tx_dma);
    2a54:	0002f981 	jmpi	2f98 <alt_avalon_sgdma_init>

00002a58 <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
    2a58:	20800317 	ldw	r2,12(r4)
    2a5c:	10800404 	addi	r2,r2,16
    2a60:	10c00037 	ldwio	r3,0(r2)
    2a64:	18e00034 	orhi	r3,r3,32768
    2a68:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2a6c:	20800317 	ldw	r2,12(r4)
    2a70:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    2a74:	20c00917 	ldw	r3,36(r4)
    2a78:	18000d26 	beq	r3,zero,2ab0 <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
    2a7c:	defffe04 	addi	sp,sp,-8
    2a80:	dfc00115 	stw	ra,4(sp)
    2a84:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2a88:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2a8c:	00bfff84 	movi	r2,-2
    2a90:	8084703a 	and	r2,r16,r2
    2a94:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
    2a98:	21000a17 	ldw	r4,40(r4)
    2a9c:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2aa0:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
    2aa4:	dfc00117 	ldw	ra,4(sp)
    2aa8:	dc000017 	ldw	r16,0(sp)
    2aac:	dec00204 	addi	sp,sp,8
    2ab0:	f800283a 	ret

00002ab4 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
    2ab4:	20c00317 	ldw	r3,12(r4)
    2ab8:	18800037 	ldwio	r2,0(r3)
    2abc:	1080040c 	andi	r2,r2,16
    2ac0:	1000191e 	bne	r2,zero,2b28 <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2ac4:	18c00404 	addi	r3,r3,16
    2ac8:	19c00037 	ldwio	r7,0(r3)
    2acc:	01bff7c4 	movi	r6,-33
    2ad0:	398c703a 	and	r6,r7,r6
    2ad4:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2ad8:	20c00317 	ldw	r3,12(r4)
    2adc:	01803fc4 	movi	r6,255
    2ae0:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
    2ae4:	20c00317 	ldw	r3,12(r4)
    2ae8:	19400835 	stwio	r5,32(r3)
    2aec:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
    2af0:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2af4:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
    2af8:	28000526 	beq	r5,zero,2b10 <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2afc:	19400037 	ldwio	r5,0(r3)

    control |= (dev->chain_control                          |
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2b00:	21000b17 	ldw	r4,44(r4)
    2b04:	21001814 	ori	r4,r4,96
    2b08:	2148b03a 	or	r4,r4,r5
    2b0c:	00000406 	br	2b20 <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2b10:	19400037 	ldwio	r5,0(r3)
    2b14:	013ffbc4 	movi	r4,-17
    2b18:	2908703a 	and	r4,r5,r4

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2b1c:	21001814 	ori	r4,r4,96
    2b20:	19000035 	stwio	r4,0(r3)
    2b24:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
    2b28:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
    2b2c:	f800283a 	ret

00002b30 <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
    2b30:	20c00317 	ldw	r3,12(r4)
    2b34:	18800037 	ldwio	r2,0(r3)
    2b38:	1080040c 	andi	r2,r2,16
    2b3c:	103ffc1e 	bne	r2,zero,2b30 <_gp+0xffff7868>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2b40:	18c00404 	addi	r3,r3,16
    2b44:	19800037 	ldwio	r6,0(r3)
    2b48:	00bff7c4 	movi	r2,-33
    2b4c:	308c703a 	and	r6,r6,r2
    2b50:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2b54:	20c00317 	ldw	r3,12(r4)
    2b58:	01803fc4 	movi	r6,255
    2b5c:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
    2b60:	20c00317 	ldw	r3,12(r4)
    2b64:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2b68:	20c00317 	ldw	r3,12(r4)
    2b6c:	18c00404 	addi	r3,r3,16
    2b70:	19400037 	ldwio	r5,0(r3)
    2b74:	29401814 	ori	r5,r5,96
    2b78:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
    2b7c:	20c00317 	ldw	r3,12(r4)
    2b80:	19400037 	ldwio	r5,0(r3)
    2b84:	2940040c 	andi	r5,r5,16
    2b88:	283ffc1e 	bne	r5,zero,2b7c <_gp+0xffff78b4>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
    2b8c:	18c00404 	addi	r3,r3,16
    2b90:	19400037 	ldwio	r5,0(r3)
    2b94:	2884703a 	and	r2,r5,r2
    2b98:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
    2b9c:	20c00317 	ldw	r3,12(r4)
    2ba0:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2ba4:	01003fc4 	movi	r4,255
    2ba8:	19000035 	stwio	r4,0(r3)

  return status;
}
    2bac:	f800283a 	ret

00002bb0 <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
    2bb0:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
    2bb4:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
    2bb8:	21800b15 	stw	r6,44(r4)
    2bbc:	f800283a 	ret

00002bc0 <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2bc0:	20800317 	ldw	r2,12(r4)
    2bc4:	10800404 	addi	r2,r2,16
    2bc8:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2bcc:	18c00814 	ori	r3,r3,32
    2bd0:	10c00035 	stwio	r3,0(r2)
    2bd4:	f800283a 	ret

00002bd8 <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2bd8:	20800317 	ldw	r2,12(r4)
    2bdc:	10800404 	addi	r2,r2,16
    2be0:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2be4:	00fff7c4 	movi	r3,-33
    2be8:	20c6703a 	and	r3,r4,r3
    2bec:	10c00035 	stwio	r3,0(r2)
    2bf0:	f800283a 	ret

00002bf4 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
    2bf4:	208007a3 	ldbuio	r2,30(r4)
    2bf8:	10801fcc 	andi	r2,r2,127
    2bfc:	1000041e 	bne	r2,zero,2c10 <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
    2c00:	208007e3 	ldbuio	r2,31(r4)
    2c04:	1080200c 	andi	r2,r2,128
    2c08:	1000031e 	bne	r2,zero,2c18 <alt_avalon_sgdma_check_descriptor_status+0x24>
    2c0c:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
    2c10:	00bffec4 	movi	r2,-5
    2c14:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
    2c18:	00bfe244 	movi	r2,-119
  }

    return 0;
}
    2c1c:	f800283a 	ret

00002c20 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
    2c20:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
    2c24:	d1600a04 	addi	r5,gp,-32728
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
    2c28:	dc000015 	stw	r16,0(sp)
    2c2c:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
    2c30:	00030b00 	call	30b0 <alt_find_dev>
    2c34:	1021883a 	mov	r16,r2

  if (NULL == dev) {
    2c38:	1000071e 	bne	r2,zero,2c58 <alt_avalon_sgdma_open+0x38>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
    2c3c:	d0a00c17 	ldw	r2,-32720(gp)
    2c40:	10000226 	beq	r2,zero,2c4c <alt_avalon_sgdma_open+0x2c>
    2c44:	103ee83a 	callr	r2
    2c48:	00000106 	br	2c50 <alt_avalon_sgdma_open+0x30>
    2c4c:	d0a03904 	addi	r2,gp,-32540
    ALT_ERRNO = ENODEV;
    2c50:	00c004c4 	movi	r3,19
    2c54:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
    2c58:	8005883a 	mov	r2,r16
    2c5c:	dfc00117 	ldw	ra,4(sp)
    2c60:	dc000017 	ldw	r16,0(sp)
    2c64:	dec00204 	addi	sp,sp,8
    2c68:	f800283a 	ret

00002c6c <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2c6c:	20c00317 	ldw	r3,12(r4)
    2c70:	18c00404 	addi	r3,r3,16
    2c74:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
    2c78:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2c7c:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
    2c80:	10bfffc4 	addi	r2,r2,-1
    2c84:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2c88:	295ffc2c 	andhi	r5,r5,32752
    2c8c:	29400134 	orhi	r5,r5,4
    2c90:	288ab03a 	or	r5,r5,r2
    2c94:	19400035 	stwio	r5,0(r3)
    2c98:	f800283a 	ret

00002c9c <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
    2c9c:	20800317 	ldw	r2,12(r4)
    2ca0:	10800404 	addi	r2,r2,16
    2ca4:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
    2ca8:	00ffff34 	movhi	r3,65532
    2cac:	18ffffc4 	addi	r3,r3,-1
    2cb0:	20c6703a 	and	r3,r4,r3
    2cb4:	10c00035 	stwio	r3,0(r2)
    2cb8:	f800283a 	ret

00002cbc <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    2cbc:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
    2cc0:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    2cc4:	10801fcc 	andi	r2,r2,127
    2cc8:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2ccc:	3004d23a 	srli	r2,r6,8
    2cd0:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
    2cd4:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2cd8:	20800045 	stb	r2,1(r4)
    2cdc:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2ce0:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2ce4:	300cd63a 	srli	r6,r6,24
    2ce8:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
    2cec:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
    2cf0:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
    2cf4:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
    2cf8:	20800245 	stb	r2,9(r4)
    2cfc:	3804d43a 	srli	r2,r7,16
    2d00:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
    2d04:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
    2d08:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
    2d0c:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
    2d10:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
    2d14:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2d18:	20800445 	stb	r2,17(r4)
    2d1c:	2804d43a 	srli	r2,r5,16
    2d20:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
    2d24:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2d28:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
    2d2c:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
    2d30:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
    2d34:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
    2d38:	20800605 	stb	r2,24(r4)
    2d3c:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
    2d40:	20000345 	stb	zero,13(r4)
    2d44:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
    2d48:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
    2d4c:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
    2d50:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
    2d54:	20000505 	stb	zero,20(r4)
    2d58:	20000545 	stb	zero,21(r4)
    2d5c:	20000585 	stb	zero,22(r4)
    2d60:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
    2d64:	20000705 	stb	zero,28(r4)
    2d68:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
    2d6c:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
    2d70:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
    2d74:	d8800517 	ldw	r2,20(sp)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
    2d78:	d9400117 	ldw	r5,4(sp)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
    2d7c:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
    2d80:	d8800217 	ldw	r2,8(sp)
    2d84:	280ac03a 	cmpne	r5,r5,zero
    2d88:	297fe004 	addi	r5,r5,-128
    2d8c:	1004c03a 	cmpne	r2,r2,zero
    2d90:	1004907a 	slli	r2,r2,1
    2d94:	2884b03a 	or	r2,r5,r2
    2d98:	d9400317 	ldw	r5,12(sp)
    2d9c:	280ac03a 	cmpne	r5,r5,zero
    2da0:	280a90ba 	slli	r5,r5,2
    2da4:	114ab03a 	or	r5,r2,r5
    2da8:	18803fcc 	andi	r2,r3,255
    2dac:	10000326 	beq	r2,zero,2dbc <alt_avalon_sgdma_construct_descriptor_burst+0x100>
    2db0:	18c003cc 	andi	r3,r3,15
    2db4:	180490fa 	slli	r2,r3,3
    2db8:	00000106 	br	2dc0 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
    2dbc:	0005883a 	mov	r2,zero
    2dc0:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
    2dc4:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
    2dc8:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
    2dcc:	000301c1 	jmpi	301c <alt_dcache_flush>

00002dd0 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
    2dd0:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
    2dd4:	d8800c17 	ldw	r2,48(sp)
    2dd8:	d8000615 	stw	zero,24(sp)
    2ddc:	d8000115 	stw	zero,4(sp)
    2de0:	d8800515 	stw	r2,20(sp)
    2de4:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
    2de8:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
    2dec:	d8800415 	stw	r2,16(sp)
    2df0:	d8800a17 	ldw	r2,40(sp)
    2df4:	d8800315 	stw	r2,12(sp)
    2df8:	d8800917 	ldw	r2,36(sp)
    2dfc:	d8800215 	stw	r2,8(sp)
    2e00:	d880080b 	ldhu	r2,32(sp)
    2e04:	d8800015 	stw	r2,0(sp)
    2e08:	0002cbc0 	call	2cbc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
    2e0c:	dfc00717 	ldw	ra,28(sp)
    2e10:	dec00804 	addi	sp,sp,32
    2e14:	f800283a 	ret

00002e18 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
    2e18:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
    2e1c:	d8800817 	ldw	r2,32(sp)
    2e20:	d8000415 	stw	zero,16(sp)
    2e24:	d8000315 	stw	zero,12(sp)
    2e28:	d8800215 	stw	r2,8(sp)
    2e2c:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
    2e30:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
    2e34:	d8800115 	stw	r2,4(sp)
    2e38:	d880060b 	ldhu	r2,24(sp)
    2e3c:	d8800015 	stw	r2,0(sp)
    2e40:	0002dd00 	call	2dd0 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
    2e44:	dfc00517 	ldw	ra,20(sp)
    2e48:	dec00604 	addi	sp,sp,24
    2e4c:	f800283a 	ret

00002e50 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
    2e50:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
    2e54:	d8800917 	ldw	r2,36(sp)
    2e58:	39ffffcc 	andi	r7,r7,65535
    2e5c:	d9c00015 	stw	r7,0(sp)
    2e60:	d8800515 	stw	r2,20(sp)
    2e64:	d8800817 	ldw	r2,32(sp)
    2e68:	300f883a 	mov	r7,r6
    2e6c:	d8000615 	stw	zero,24(sp)
    2e70:	d8000415 	stw	zero,16(sp)
    2e74:	d8800315 	stw	r2,12(sp)
    2e78:	d8000215 	stw	zero,8(sp)
    2e7c:	d8000115 	stw	zero,4(sp)
    2e80:	000d883a 	mov	r6,zero
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
    2e84:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
    2e88:	0002cbc0 	call	2cbc <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
    2e8c:	dfc00717 	ldw	ra,28(sp)
    2e90:	dec00804 	addi	sp,sp,32
    2e94:	f800283a 	ret

00002e98 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
    2e98:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
    2e9c:	d8800317 	ldw	r2,12(sp)
    2ea0:	d8000115 	stw	zero,4(sp)
    2ea4:	39ffffcc 	andi	r7,r7,65535
    2ea8:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
    2eac:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
    2eb0:	0002e500 	call	2e50 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
    2eb4:	dfc00217 	ldw	ra,8(sp)
    2eb8:	dec00304 	addi	sp,sp,12
    2ebc:	f800283a 	ret

00002ec0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
    2ec0:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
    2ec4:	d8800c03 	ldbu	r2,48(sp)
    2ec8:	39ffffcc 	andi	r7,r7,65535
    2ecc:	d9c00015 	stw	r7,0(sp)
    2ed0:	d8800615 	stw	r2,24(sp)
    2ed4:	d8800b17 	ldw	r2,44(sp)
    2ed8:	d8000515 	stw	zero,20(sp)
    2edc:	000f883a 	mov	r7,zero
    2ee0:	d8800415 	stw	r2,16(sp)
    2ee4:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
    2ee8:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
    2eec:	d8800315 	stw	r2,12(sp)
    2ef0:	d8800817 	ldw	r2,32(sp)
    2ef4:	d8800215 	stw	r2,8(sp)
    2ef8:	d8800a17 	ldw	r2,40(sp)
    2efc:	d8800115 	stw	r2,4(sp)
    2f00:	0002cbc0 	call	2cbc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
    2f04:	dfc00717 	ldw	ra,28(sp)
    2f08:	dec00804 	addi	sp,sp,32
    2f0c:	f800283a 	ret

00002f10 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
    2f10:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
    2f14:	d8800903 	ldbu	r2,36(sp)
    2f18:	d8000315 	stw	zero,12(sp)
    2f1c:	39ffffcc 	andi	r7,r7,65535
    2f20:	d8800415 	stw	r2,16(sp)
    2f24:	d8800817 	ldw	r2,32(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
    2f28:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
    2f2c:	d8800215 	stw	r2,8(sp)
    2f30:	d8800717 	ldw	r2,28(sp)
    2f34:	d8800115 	stw	r2,4(sp)
    2f38:	d8800617 	ldw	r2,24(sp)
    2f3c:	d8800015 	stw	r2,0(sp)
    2f40:	0002ec00 	call	2ec0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
    2f44:	dfc00517 	ldw	ra,20(sp)
    2f48:	dec00604 	addi	sp,sp,24
    2f4c:	f800283a 	ret

00002f50 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
    2f50:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
    2f54:	d8800c03 	ldbu	r2,48(sp)
    2f58:	d8000515 	stw	zero,20(sp)
    2f5c:	d8000415 	stw	zero,16(sp)
    2f60:	d8800615 	stw	r2,24(sp)
    2f64:	d8800b17 	ldw	r2,44(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
    2f68:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
    2f6c:	d8800315 	stw	r2,12(sp)
    2f70:	d8800a17 	ldw	r2,40(sp)
    2f74:	d8800215 	stw	r2,8(sp)
    2f78:	d8800917 	ldw	r2,36(sp)
    2f7c:	d8800115 	stw	r2,4(sp)
    2f80:	d880080b 	ldhu	r2,32(sp)
    2f84:	d8800015 	stw	r2,0(sp)
    2f88:	0002cbc0 	call	2cbc <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
    2f8c:	dfc00717 	ldw	ra,28(sp)
    2f90:	dec00804 	addi	sp,sp,32
    2f94:	f800283a 	ret

00002f98 <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2f98:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
    2f9c:	defffb04 	addi	sp,sp,-20
    2fa0:	dc800315 	stw	r18,12(sp)
    2fa4:	dc400215 	stw	r17,8(sp)
    2fa8:	dc000115 	stw	r16,4(sp)
    2fac:	dfc00415 	stw	ra,16(sp)
    2fb0:	2021883a 	mov	r16,r4
    2fb4:	2823883a 	mov	r17,r5
    2fb8:	3025883a 	mov	r18,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2fbc:	00800074 	movhi	r2,1
    2fc0:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
    2fc4:	20c00317 	ldw	r3,12(r4)
    2fc8:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
    2fcc:	20800317 	ldw	r2,12(r4)
    2fd0:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
    2fd4:	20800317 	ldw	r2,12(r4)
    2fd8:	00c03fc4 	movi	r3,255
    2fdc:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
    2fe0:	d1600a04 	addi	r5,gp,-32728
    2fe4:	00030440 	call	3044 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
    2fe8:	01800034 	movhi	r6,0
    2fec:	d8000015 	stw	zero,0(sp)
    2ff0:	800f883a 	mov	r7,r16
    2ff4:	318a9604 	addi	r6,r6,10840
    2ff8:	900b883a 	mov	r5,r18
    2ffc:	8809883a 	mov	r4,r17
    3000:	00028000 	call	2800 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
    3004:	dfc00417 	ldw	ra,16(sp)
    3008:	dc800317 	ldw	r18,12(sp)
    300c:	dc400217 	ldw	r17,8(sp)
    3010:	dc000117 	ldw	r16,4(sp)
    3014:	dec00504 	addi	sp,sp,20
    3018:	f800283a 	ret

0000301c <alt_dcache_flush>:
void alt_dcache_flush (void* start, alt_u32 len)
{
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
    301c:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
    3020:	2005883a 	mov	r2,r4
    3024:	1140032e 	bgeu	r2,r5,3034 <alt_dcache_flush+0x18>
  { 
    ALT_FLUSH_DATA(i); 
    3028:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
    302c:	10800804 	addi	r2,r2,32
    3030:	003ffc06 	br	3024 <_gp+0xffff7d5c>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
    3034:	210007cc 	andi	r4,r4,31
    3038:	20000126 	beq	r4,zero,3040 <alt_dcache_flush+0x24>
  {
    ALT_FLUSH_DATA(i);
    303c:	1000001b 	flushda	0(r2)
    3040:	f800283a 	ret

00003044 <alt_dev_llist_insert>:
    3044:	20000226 	beq	r4,zero,3050 <alt_dev_llist_insert+0xc>
    3048:	20800217 	ldw	r2,8(r4)
    304c:	1000101e 	bne	r2,zero,3090 <alt_dev_llist_insert+0x4c>
    3050:	d0a00c17 	ldw	r2,-32720(gp)
    3054:	10000926 	beq	r2,zero,307c <alt_dev_llist_insert+0x38>
    3058:	deffff04 	addi	sp,sp,-4
    305c:	dfc00015 	stw	ra,0(sp)
    3060:	103ee83a 	callr	r2
    3064:	00c00584 	movi	r3,22
    3068:	10c00015 	stw	r3,0(r2)
    306c:	00bffa84 	movi	r2,-22
    3070:	dfc00017 	ldw	ra,0(sp)
    3074:	dec00104 	addi	sp,sp,4
    3078:	f800283a 	ret
    307c:	d0a03904 	addi	r2,gp,-32540
    3080:	00c00584 	movi	r3,22
    3084:	10c00015 	stw	r3,0(r2)
    3088:	00bffa84 	movi	r2,-22
    308c:	f800283a 	ret
    3090:	28800017 	ldw	r2,0(r5)
    3094:	21400115 	stw	r5,4(r4)
    3098:	20800015 	stw	r2,0(r4)
    309c:	28800017 	ldw	r2,0(r5)
    30a0:	11000115 	stw	r4,4(r2)
    30a4:	29000015 	stw	r4,0(r5)
    30a8:	0005883a 	mov	r2,zero
    30ac:	f800283a 	ret

000030b0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
    30b0:	defffb04 	addi	sp,sp,-20
    30b4:	dcc00315 	stw	r19,12(sp)
    30b8:	dc800215 	stw	r18,8(sp)
    30bc:	dc400115 	stw	r17,4(sp)
    30c0:	dc000015 	stw	r16,0(sp)
    30c4:	dfc00415 	stw	ra,16(sp)
    30c8:	2027883a 	mov	r19,r4
    30cc:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
    30d0:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
    30d4:	00032140 	call	3214 <strlen>
    30d8:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
    30dc:	84400726 	beq	r16,r17,30fc <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
    30e0:	81000217 	ldw	r4,8(r16)
    30e4:	900d883a 	mov	r6,r18
    30e8:	980b883a 	mov	r5,r19
    30ec:	00031e40 	call	31e4 <memcmp>
    30f0:	10000426 	beq	r2,zero,3104 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
    30f4:	84000017 	ldw	r16,0(r16)
    30f8:	003ff806 	br	30dc <_gp+0xffff7e14>
  }
  
  /* No match found */
  
  return NULL;
    30fc:	0005883a 	mov	r2,zero
    3100:	00000106 	br	3108 <alt_find_dev+0x58>
    3104:	8005883a 	mov	r2,r16
}
    3108:	dfc00417 	ldw	ra,16(sp)
    310c:	dcc00317 	ldw	r19,12(sp)
    3110:	dc800217 	ldw	r18,8(sp)
    3114:	dc400117 	ldw	r17,4(sp)
    3118:	dc000017 	ldw	r16,0(sp)
    311c:	dec00504 	addi	sp,sp,20
    3120:	f800283a 	ret

00003124 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
    3124:	01440004 	movi	r5,4096
    3128:	0009883a 	mov	r4,zero
    312c:	00031ac1 	jmpi	31ac <alt_icache_flush>

00003130 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
    3130:	213ffe84 	addi	r4,r4,-6
    3134:	008003c4 	movi	r2,15
    3138:	11001636 	bltu	r2,r4,3194 <alt_exception_cause_generated_bad_addr+0x64>
    313c:	200890ba 	slli	r4,r4,2
    3140:	00800034 	movhi	r2,0
    3144:	108c5504 	addi	r2,r2,12628
    3148:	2089883a 	add	r4,r4,r2
    314c:	20800017 	ldw	r2,0(r4)
    3150:	1000683a 	jmp	r2
    3154:	0000319c 	xori	zero,zero,198
    3158:	0000319c 	xori	zero,zero,198
    315c:	00003194 	movui	zero,198
    3160:	00003194 	movui	zero,198
    3164:	00003194 	movui	zero,198
    3168:	0000319c 	xori	zero,zero,198
    316c:	00003194 	movui	zero,198
    3170:	00003194 	movui	zero,198
    3174:	0000319c 	xori	zero,zero,198
    3178:	0000319c 	xori	zero,zero,198
    317c:	00003194 	movui	zero,198
    3180:	0000319c 	xori	zero,zero,198
    3184:	00003194 	movui	zero,198
    3188:	00003194 	movui	zero,198
    318c:	00003194 	movui	zero,198
    3190:	0000319c 	xori	zero,zero,198
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
    3194:	0005883a 	mov	r2,zero
    3198:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
    319c:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
    31a0:	f800283a 	ret

000031a4 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    31a4:	000170fa 	wrctl	ienable,zero
    31a8:	f800283a 	ret

000031ac <alt_icache_flush>:
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
    31ac:	00840004 	movi	r2,4096
    31b0:	1140012e 	bgeu	r2,r5,31b8 <alt_icache_flush+0xc>
    31b4:	100b883a 	mov	r5,r2
    31b8:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    31bc:	2005883a 	mov	r2,r4
    31c0:	1140032e 	bgeu	r2,r5,31d0 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
    31c4:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
    31c8:	10800804 	addi	r2,r2,32
    31cc:	003ffc06 	br	31c0 <_gp+0xffff7ef8>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
    31d0:	210007cc 	andi	r4,r4,31
    31d4:	20000126 	beq	r4,zero,31dc <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
    31d8:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
    31dc:	0000203a 	flushp
    31e0:	f800283a 	ret

000031e4 <memcmp>:
    31e4:	218d883a 	add	r6,r4,r6
    31e8:	21800826 	beq	r4,r6,320c <memcmp+0x28>
    31ec:	20800003 	ldbu	r2,0(r4)
    31f0:	28c00003 	ldbu	r3,0(r5)
    31f4:	10c00226 	beq	r2,r3,3200 <memcmp+0x1c>
    31f8:	10c5c83a 	sub	r2,r2,r3
    31fc:	f800283a 	ret
    3200:	21000044 	addi	r4,r4,1
    3204:	29400044 	addi	r5,r5,1
    3208:	003ff706 	br	31e8 <_gp+0xffff7f20>
    320c:	0005883a 	mov	r2,zero
    3210:	f800283a 	ret

00003214 <strlen>:
    3214:	2005883a 	mov	r2,r4
    3218:	10c00007 	ldb	r3,0(r2)
    321c:	18000226 	beq	r3,zero,3228 <strlen+0x14>
    3220:	10800044 	addi	r2,r2,1
    3224:	003ffc06 	br	3218 <_gp+0xffff7f50>
    3228:	1105c83a 	sub	r2,r2,r4
    322c:	f800283a 	ret
